/*
 * Авторское право принадлежит Антону Александровичу Астафьеву <anton@astafiev.me> ѱ 2017.
 * Все права защищены и охраняются законом.
 * Copyright (c) 2017 Anton Astafiev <anton@astafiev.me>. All rights reserved.
 *
 *  Собственная лицензия Астафьева
 * Данный программный код является собственностью Астафьева Антона Александровича
 * и может быть использован только с его личного разрешения
 */

пакет эллиптика.ява.морфемика.логика;

внеся java.util.Objects;
внеся java.util.Итерируемое;
внеся java.util.Коллекции;
внеся java.util.Массивы;
внеся java.util.Множество;
внеся java.util.ПорядковыйСписок;
внеся java.util.Словарь;
внеся java.util.Список;
внеся java.util.ТаблицаСвёрток;
внеся org.elliptica.ling.Morph;
внеся org.elliptica.ling.Граммема;
внеся org.elliptica.ling.Парадигма;
внеся org.elliptica.ling.РезультатСлова;
внеся org.elliptica.ling.ЧастьРечи;
внеся эллиптика.ява.морфемика.Морфема;
внеся статичный эллиптика.ява.морфемика.логика.Разбор.Состояние.*;
внеся эллиптика.ява.морфемика.ТипМорфемы;
внеся эллиптика.ява.морфемика.ячейки.ЗаписьМорфемы;
внеся эллиптика.ява.утилиты.ОбратноеПробегаемое;


/**
 *
 * @автор Антон Александрович Астафьев {@буквально <anton@astafiev.me>} (Anton Astafiev)
 */
доступный класс Разбор {

	доступный статичный логическое отглагольноеЛиИмя(Строка строка, ЧастьРечи частьРечи, ширцел маска_граммем) {
		если (частьРечи != ЧастьРечи.существительное){
			верни ложь;
		}
		Подборщик подборщик = Подборщик.экзмепляр();
		Список<Список<Морфема>> варианты = подборщик.подбери(строка, частьРечи, маска_граммем);
		для (Список<Морфема> структура: варианты){
			ЧастьРечи текЧР = ничто;
			для (Морфема морф:  обратно(структура)){
				если (морф.дайТип() != ТипМорфемы.СУФФИКС){
					прерви;
				}
				если (цельСовместима(ЧастьРечи.существительное, морф)){
					если (морф.базоваяЧастьРечи() == ЧастьРечи.глагол){
						верни истина;
					}
					возобнови;
				}
				если (цельСовместима(ЧастьРечи.глагол, морф)){
					текЧР = ЧастьРечи.глагол;
				}
				прерви;
			}
			если (текЧР == ЧастьРечи.глагол){
				верни истина;
			}
		}
		верни ложь;
	}

	личный статичный логическое цельСовместима(ЧастьРечи цель, Морфема м){
		если (цель == м.целеваяЧастьРечи() || цель == ЧастьРечи.любой){
			верни истина;
		}
		если (м.целеваяЧастьРечи() == ЧастьРечи.тотже && (цель == м.базоваяЧастьРечи() || м.базоваяЧастьРечи() == ЧастьРечи.любой)){
			верни истина;
		}
		верни ложь;
	}

	личный логическое исходникСовместим(ЧастьРечи исходник, Морфема м){
		верни исходник == м.базоваяЧастьРечи() || исходник == ЧастьРечи.любой;
	}

	доступный Строка отглагольноеИмя(Строка строка) {
		если (строка == ничто) верни ничто;
		итоговый ЧастьРечи частьРечи = ЧастьРечи.инфинитив;
		Подборщик подборщик = Подборщик.экзмепляр();
		Список<Список<Морфема>> варианты = подборщик.подбери(строка, частьРечи, 0);
		Строка результат = ничто;
верх:
		для (Список<Морфема> структура: варианты){
			Состояние состояние = ИНФИНИТИВ;
			для (цел и = структура.размер()-1; и >= 0 && состояние != ОШИБКА; и-- ){
				Морфема морф = структура.дай(и);
				Состояние след;
				если (морф экземпляр ЗаписьМорфемы) {
					ЗаписьМорфемы зм = (ЗаписьМорфемы) морф;
					след = состояния.дай(зм.дайРазл());
				} иначе {
					след = КОРЕНЬ;
				}

				пока (след != ничто) {
					Действие д = ПОЗИЦИИ.дай(новый Пара(состояние, след));
					если (д == ничто) {
						след = ничто;
						состояние = ОШИБКА;
						прерви;
					}
					если ( !д.пропуск) {
						Строка рез = подборКонцовки(структура.подСписок(0, и + д.отступ), д.суффиксы, д.чередование);
						если (рез != ничто){
							верни рез;
						}
					}
					состояние = след;
					след = д.следующийШаг;
				}
			}
			если (состояние == ГОТОВО) {
				прерви;
			}
		}
		верни результат;
	}

	личный статичный итоговый Object[][] СПИСОК_СОСТОЯНИЙ = {
		//Исх сост.		Целевое сост	Пропуск		Отступ	Суффиксы		Чередование		След сост
		{ИНФИНИТИВ,		ОСНОВА,			ложь,		0,		"в,ениj",	см(),			ничто}, // ть -> в
		{ИНФИНИТИВ,		ПРЕДОСНОВА,		ложь,		0,		"ениj",		см("с-д"),		ничто},	// ти -> ение
		{ОСНОВА,			ПРЕДОСНОВА,		ложь,		1,		"ниj,тиj",	см(),		ПРЕДОСНОВА_А},	// а-ть -> а-ние, а-тие
		{ОСНОВА,			ПРЕДОСНОВА_Я,	ложь,		1,		"ниj,тиj",	см(),		ПРЕДОСНОВА_Я},	// я-ть -> я-ние, я-тие
		{ПРЕДОСНОВА,		ПРЕДОСНОВА_А,	ложь,		0,		"к",		см(),			ничто},	// а-ть -> ка
		{ПРЕДОСНОВА_А,	ПРЕДОСНОВА_ОВ,	истина,		1,		ничто,		см(),			ничто},	// ов-а-ть -> ов-а-ние
		{ПРЕДОСНОВА_ОВ,	ПРЕДОСНОВА_ИР,	ложь,		0,		"яциj",		см("ц-к"),		ничто},	// ир-ов-а-ть -> ация
		{ПРЕДОСНОВА_Я,	КОРЕНЬ,			ложь,		1,		"в",		см(),			ничто},	// ять -> в
		{ПРЕДОСНОВА_Я,	ПРЕДОСНОВА_Я,	ложь,		0,		"ениj",		см(),			ничто},	// ять -> ение
		{ОСНОВА,			ПРЕДОСНОВА_И,	ложь,		0,		"ениj",		см("д-жд","в-вл"),	ПРЕДОСНОВА_И2},	// ить -> ение
		{ПРЕДОСНОВА_И,	ПРЕДОСНОВА_И2,	ложь,		0,		"к",		см(),			ничто},	// ить -> ка
		// выход
	};

	личный статичный итоговый Словарь<Integer, Состояние> состояния;
	статичный {
		состояния = новый ТаблицаСвёрток<>(5);
		состояния.клади(1151, ПРЕДОСНОВА);		// -а
		состояния.клади(1180, ОСНОВА);			// -ть
		состояния.клади(1665, ПРЕДОСНОВА);		// -а
		состояния.клади(1666, ПРЕДОСНОВА_Я);		// -я
		состояния.клади(1084, ПРЕДОСНОВА_И);		// -и
		состояния.клади(1667, ПРЕДОСНОВА_ОВ);	// -ов
		состояния.клади(1194, ПРЕДОСНОВА_ИР);	// -ир
	}

	статичный переч Состояние {
		ИНФИНИТИВ, ОСНОВА, ПРЕДОСНОВА, ПРЕДОСНОВА_А, ПРЕДОСНОВА_И, ПРЕДОСНОВА_И2, ПРЕДОСНОВА_Я, ПРЕДОСНОВА_ОВ, ПРЕДОСНОВА_ИР, КОРЕНЬ, ГОТОВО, ОШИБКА
	}
	
	личный статичный класс Действие {
		Пара направление;
		логическое пропуск;
		цел отступ;
		Строка суффиксы;
		Строка[] чередование;
		Состояние следующийШаг;

		доступный Действие(Пара направление, логическое пропуск, цел отступ, Строка суффиксы, Строка[] чередование, Состояние следующийШаг) {
			это.направление = направление;
			это.пропуск = пропуск;
			это.отступ = отступ;
			это.суффиксы = суффиксы;
			это.чередование = чередование;
			это.следующийШаг = следующийШаг;
		}
	}

	личный статичный Строка[] см(Строка... пар) {
		верни пар;
	}

	личный статичный итоговый Словарь<Пара, Действие> ПОЗИЦИИ = новый ТаблицаСвёрток<>(Состояние.values().length * 2);
	статичный {
		для (Object[] поз: СПИСОК_СОСТОЯНИЙ){
			Пара ключ = новый Пара((Состояние)поз[0], (Состояние)поз[1]);
			Действие действие = новый Действие(ключ,
					(логическое)поз[2], (цел)поз[3],
					(Строка)поз[4], (Строка[])поз[5], (Состояние)поз[6]
			);
			ПОЗИЦИИ.клади(ключ, действие);
		}
	}

	личный статичный класс Пара {
		итоговый Состояние исходное;
		итоговый Состояние цель;

		доступный Пара(Состояние исходное, Состояние цель) {
			это.исходное = исходное;
			это.цель = цель;
		}

		@Подмени
		доступный Строка toString() {
			верни "Пара{" + "исходное=" + исходное + ", цель=" + цель + '}';
		}

		@Подмени
		доступный логическое equals(Object об) {
			если (это == об) {
				верни истина;
			}
			если (об == ничто) {
				верни ложь;
			}
			если (дайКласс()!= об.дайКласс()) {
				верни ложь;
			}
			итоговый Пара др = (Пара) об;
			если (это.исходное != др.исходное || это.цель != др.цель) {
				верни ложь;
			}
			верни истина;
		}

		@Подмени
		доступный цел hashCode() {
			цел hash = 5;
			hash = 29 * hash + Objects.hashCode(исходное);
			hash = 29 * hash + Objects.hashCode(цель);
			верни hash;
		}
	}

	личный Строка подборКонцовки(Список<Морфема> начальные, Строка маска, Строка... чередования) {
		Список<ЗаписьМорфемы> суффиксы = Подборщик.экзмепляр().поиск(маска).дайСписокРезультатов();
		StringBuilder начало = новый StringBuilder();
		для (Морфема морфема: начальные){
			начало.append(морфема.значение());
		}
		Список<Строка> замены = новый ПорядковыйСписок<>(1+чередования.length);
		Коллекции.добавьВсе(замены, (Строка) ничто);
		Коллекции.добавьВсе(замены, чередования);
		для (Строка замена: замены){
			Строка старт = начало.строкой();
			если (замена != ничто){
				Строка[] шаблоны = замена.разорви("-");
				если (!старт.заканчиваетсяНа(шаблоны[0])){
					возобнови;
				}
				старт = старт.подстрока(0, старт.длина()-шаблоны[0].длина()) + шаблоны[1];
			}
			для (ЗаписьМорфемы суффикс: суффиксы) {
				Строка вариант = вариантОтглагольного(старт, суффикс);
				РезультатСлова результатСлова = Morph.найдиСлово(вариант);
				для (Парадигма парадигма: результатСлова.дайПарадигмы()){
					если (парадигма.былоНайдено() &&
							парадигма.дайЧастьРечи() == ЧастьРечи.существительное &&
							парадигма.дайГраммемы().содержитВсе(Массивы.списком(Граммема.именительный, Граммема.единственное))){
						верни вариант;
					}
				}
			}
		}
		верни ничто;
	}
	
	личный Строка вариантОтглагольного(Строка старт, ЗаписьМорфемы суффикс) {
		Множество<Граммема> гр = суффикс.дайЦелевыеГраммемы();
		Строка значСуф = суффикс.значение();
		логическое мягкий = значСуф.заканчиваетсяНа("j");
		значСуф = значСуф.замени("j", "");
		если (гр.содержит(Граммема.женский)) {
			значСуф = значСуф + (мягкий ? "я" : "а");
		} иначе если (гр.содержит(Граммема.средний)) {
			значСуф = значСуф + (мягкий ? "е" : "о");
		} иначе {
			значСуф = значСуф + (мягкий ? "е" : "");
		}
		верни старт + значСуф;
	}
	
	личный статичный Итерируемое<Морфема> обратно(Список<Морфема> список){
		верни новый ОбратноеПробегаемое<>(список);
	}
	
}
