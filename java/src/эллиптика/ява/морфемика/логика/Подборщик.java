/*
 * Авторское право принадлежит Антону Александровичу Астафьеву <anton@astafiev.me> ѱ 2017.
 * Все права защищены и охраняются законом.
 * Copyright (c) 2017 Anton Astafiev <anton@astafiev.me>. All rights reserved.
 *
 *  Собственная лицензия Астафьева
 * Данный программный код является собственностью Астафьева Антона Александровича
 * и может быть использован только с его личного разрешения
 */

пакет эллиптика.ява.морфемика.логика;

внеся java.util.Collections;
внеся java.util.TreeSet;
внеся java.util.logging.Level;
внеся java.util.logging.Logger;
внеся java.util.stream.Collectors;
внеся java.util.Коллекция;
внеся java.util.Массивы;
внеся java.util.ПорядковыйСписок;
внеся java.util.РанжированноеМножество;
внеся java.util.Список;
внеся javax.persistence.criteria.Predicate;
внеся javax.persistence.criteria.Root;
внеся javax.persistence.metamodel.Attribute;
внеся javax.persistence.metamodel.ListAttribute;
внеся javax.persistence.metamodel.PluralAttribute;
внеся javax.persistence.metamodel.SingularAttribute;
внеся org.elliptica.ling.Граммема;
внеся org.elliptica.ling.ЧастьРечи;
внеся эллиптика.ява.морфемика.Морфема;
внеся эллиптика.ява.морфемика.ТипМорфемы;
внеся эллиптика.ява.морфемика.гл.ОтглСуффиксДействия;
внеся эллиптика.ява.морфемика.ячейки.MorphemDescr;
внеся эллиптика.ява.морфемика.ячейки.MorphemDescr_;
внеся эллиптика.ява.хранение.СущностеВед;
внеся эллиптика.ява.хранение.ТипизированныйЗапрос;
внеся эллиптика.ява.хранение.ФабрикаСущностеВедов;
внеся эллиптика.ява.хранение.Хранение;
внеся эллиптика.ява.хранение.критерии.Корень;
внеся эллиптика.ява.хранение.критерии.КритериальныйЗапрос;
внеся эллиптика.ява.хранение.критерии.Путь;
внеся эллиптика.ява.хранение.критерии.СборщикКритериев;
внеся эллиптика.ява.хранение.критерии.Утверждение;
внеся статичный эллиптика.ява.хранение.метамодель.Оболочки.об;


/**
 *
 * @автор Антон Александрович Астафьев {@буквально <anton@astafiev.me>} (Anton Astafiev)
 */
доступный класс Подборщик {
	
	статичный синхронизированный доступный Подборщик экзмепляр(){
		если (подборщик == ничто){
			подборщик = новый Подборщик();
		}
		верни подборщик;
	}
	
	личный статичный Подборщик подборщик;

	личный СущностеВед св;
	личный Строка гласные = "аоуэыяёюеи";
	личный Строка согласные = "";
	Список<Список<MorphemDescr>> итог;

	доступный Подборщик() {
		ФабрикаСущностеВедов фсв = Хранение.создайФабрикуСущностеВедов("LinguiticsPU");
		св = фсв.создайСущностеВед();

		согласные = "";
		для (символ сим = 'а'; сим <= 'я'; сим++){
			если (гласные.номер(сим)<0){
				согласные += сим;
			}
		}

	}
	доступный статичный тщетный main(Строка[] арг){
		Подборщик генератор = новый Подборщик();
		генератор.подбери("декларативность", ЧастьРечи.существительное);
		попробуй {
			Строка суффиксы[] = {"ат", "ив", "н", "ость"};
			генератор.запуск("деклар", суффиксы);
		} ловя (ОшибкаСловообразования ош) {
			ЖУРНАЛ.log(Level.SEVERE, ничто, ош);
		}
	}

	Строка запуск(Строка корень, Строка суффиксы[]) кидает ОшибкаСловообразования{
		Список<Морфема> слово = новый ПорядковыйСписок<>();
		слово.добавь(новый эллиптика.ява.морфемика.Корень(корень, ЧастьРечи.глагол));

		Список<? расширяет Морфема> морфемы = Массивы.списком(суффиксы).поток()
				.map(ОтглСуффиксДействия::новый).collect(Collectors.toList());

		для (Морфема морфема: морфемы){
			слово = морфема.примениК(слово);
		}
		Строка рез = слово.поток().map(м -> м.значение()).reduce("", (лев, прав) -> лев+прав);
		верни рез;
	}

	доступный Список<Список<MorphemDescr>> подбери(Строка искомое, ЧастьРечи частьРечи, ширцел граммемы){
		исходныеГраммемы = граммемы;
		Строка основа = основа(искомое, частьРечи, Граммема.дайГраммемы(граммемы));
		верни подбери_(искомое, частьРечи, основа);
	}
	доступный Список<Список<MorphemDescr>> подбери(Строка искомое, ЧастьРечи частьРечи, Граммема... граммемы){
		Список<Граммема> граммемСписок = Массивы.списком(граммемы);
		исходныеГраммемы = Граммема.маскаГраммем(граммемСписок);
		Строка основа = основа(искомое, частьРечи, граммемСписок);
		верни подбери_(искомое, частьРечи, основа);
	}

	личный Список<Список<MorphemDescr>> подбери_(Строка искомое, ЧастьРечи частьРечи, Строка основа){
		исходнаяЧастьРечи = частьРечи;
		Строка ок = искомое.подстрока(основа.длина());
		Список<Вариант> вар = поиск(основа, частьРечи, ок.пуста() ? '∅': ок.символВ(0), ничто);
		итог = новый ПорядковыйСписок<>();
		для (Вариант в: вар){
			Список<MorphemDescr> списокМорфем = новый ПорядковыйСписок<>();
			обходМорфем(в, списокМорфем, итог);
		}
		верни итог;
	}

	тщетный обходМорфем(Вариант вариант, Список<MorphemDescr> списокМорфем, Список<Список<MorphemDescr>> списки) {
		списокМорфем.добавь(вариант.getMorphemDescr());
		если (вариант.getДети() == ничто){
			Список<MorphemDescr> морфемы = новый ПорядковыйСписок<>(списокМорфем);
			Collections.reverse(морфемы);
			списки.добавь(морфемы);
			Система.вывод.print(вариант.getОстаток());
			для (цел и = списокМорфем.размер()-1; и >=0; и--){
				Система.вывод.print(списокМорфем.дай(и).дайМорфему());
			}
			Система.вывод.println();
		} иначе {
			для (Вариант в: вариант.getДети()){
				обходМорфем(в, списокМорфем, списки);
			}
		}
		списокМорфем.удали(вариант.getMorphemDescr());
	}

	личный цел глубина = 0;
	личный итоговый Строка ПРОБЕЛЫ = "                 ";
	личный ЧастьРечи исходнаяЧастьРечи;
	личный ширцел исходныеГраммемы;

	Строка основа(Строка искомое, ЧастьРечи частьРечи, Коллекция<Граммема> граммемы){
		РанжированноеМножество<Граммема> гг = новый TreeSet<>(граммемы);
		если (частьРечи == ЧастьРечи.существительное && !граммемы.пусто()){
			цел падеж = гг.хвост(Граммема.именительный).первый().ordinal()- Граммема.именительный.ordinal();
			цел число = гг.хвост(Граммема.единственное).первый().ordinal()- Граммема.единственное.ordinal();
			для (Строка[][] скл: склонения){
			Строка [] окончания = скл[падеж*2+число];
				для (Строка ок: окончания){
					если (искомое.заканчиваетсяНа(ок)){
						верни искомое.подстрока(0, искомое.длина() - ок.длина());
					}
				}
			}
			кинь новый RuntimeException("Не нашли основу");
		} иначе {
			верни искомое;
		}
	}

	личный Список<Вариант> поиск(итоговый Строка искомое, ЧастьРечи частьРечи, символ последующий, Строка язык){
		Список<MorphemDescr> варианты = запрос(искомое, частьРечи).дайСписокРезультатов();
		глубина++;
		Список<Вариант> результат = новый ПорядковыйСписок<>(варианты.размер());
		для (MorphemDescr морфема: варианты){
			если (морфема.дайТип()==ТипМорфемы.СУФФИКС && морфема.дайМорфему().заканчиваетсяНа("j") && "яюеёй".номер(последующий)<0) {
				возобнови;
			}
			вывод(морфема.строкой());
			цел длинаСуф = морфема.getОбрат().длина();
			Строка искомое_ = искомое.подстрока(0, искомое.длина() - длинаСуф);
			если (!морфема.применимаК(исходнаяЧастьРечи, исходныеГраммемы, искомое_, последующий)) {
				возобнови;
			}
			частьРечи = морфема.дайИсходныйТип();
			если (!частьРечиСоотв(частьРечи, искомое_)) {
				возобнови;
			}
			если (глубина-1 > морфема.getМаксЛеваяПозиция()) {
				возобнови;
			}
			Строка новыйЯзык = морфема.дайЯзык();
			если (новыйЯзык != ничто) {
				// обновление
				если ("русский".равна(новыйЯзык) && язык != ничто && !новыйЯзык.равна(язык)){
					// стоп точка
					возобнови;
				}
				язык = новыйЯзык;
			}
			символ начало = морфема.getОбрат().символВ(длинаСуф-1);
			Список<Вариант> рез = поиск(искомое_, частьРечи, начало, язык);
			если (!рез.пусто()){
				вывод("-успех!");
				результат.добавь(новый Вариант(морфема, рез));
			} иначе {
				вывод("-неудача!");
				результат.добавь(новый Вариант(морфема, искомое_));
			}
		}
		глубина--;
		верни результат;
	}

	личный логическое частьРечиСоотв(ЧастьРечи частьРечи, Строка остаток){
		если (остаток.пуста()){
			верни ложь;
		}
		символ конец = остаток.символВ(остаток.длина()-1);
		выбери (частьРечи){
			случай существительное:
				верни ("аяьое"+согласные).номер(конец)>=0;
			запасной:
				верни истина;
		}
	}

	личный статичный цел маскаБукв(Строка буквы) {
		цел маска = 0;
		для (символ сим: буквы.кМассивуСимволов()){
			маска |= 1 << (сим-'а');
		}
		верни маска;
	}

	личный тщетный вывод(Строка строка){
		Система.вывод.append("|");
		Система.вывод.append(ПРОБЕЛЫ, 0, 2*глубина);
		Система.вывод.println(строка);
	}

	личный ТипизированныйЗапрос<MorphemDescr> запрос(Строка искомое, ЧастьРечи частьРечи){
		СборщикКритериев ск = св.дайСборщикКритериев();
		КритериальныйЗапрос<MorphemDescr> кз = ск.создайЗапрос(MorphemDescr.класс);
		Корень<MorphemDescr> корень = кз.из(MorphemDescr.класс);

		Утверждение утверждение = частьРечи == ЧастьРечи.любой ? ск.и() :
			ск.или(
				ск.равны(путь(корень, MorphemDescr_.целевойТип), частьРечи),
				ск.равны(путь(корень,MorphemDescr_.целевойТип), ЧастьРечи.любой),
				ск.и(
					ск.равны(путь(корень,MorphemDescr_.целевойТип), ЧастьРечи.тотже),
					ск.равны(путь(корень,MorphemDescr_.исходныйТип), частьРечи)
				)
			);

		утверждение = ск.и(
				утверждение,
				ск.равны(путь(корень, MorphemDescr_.тип), ТипМорфемы.СУФФИКС),
				ск.мен(ск.длина(путь(корень, MorphemDescr_.обрат)), искомое.длина()),
				ск.равны(ск.поиск(ск.литерал(переверни(искомое)), путь(корень, MorphemDescr_.обрат)), 1)
		);
		кз.где(утверждение);

		верни св.создайЗапрос(кз);
	}
	
	личный <Ё,А> Путь<А> путь(Путь<Ё> путь, Attribute<Ё,А> attribute) {
		если (attribute экземпляр SingularAttribute) {
			SingularAttribute<Ё,А> sa = (SingularAttribute) attribute;
			верни путь.дай(об(sa));
		} иначе если (attribute экземпляр ListAttribute){
//			PluralAttribute<Ё,А,А> sa = (ListAttribute) attribute;
//			верни путь.дай(об(sa));
		}
		верни ничто;
	}

	доступный ТипизированныйЗапрос<MorphemDescr> поиск(Строка искомое){
		СборщикКритериев ск = св.дайСборщикКритериев();
		КритериальныйЗапрос<MorphemDescr> кз = ск.создайЗапрос(MorphemDescr.класс);
		Корень<MorphemDescr> корень = кз.из(MorphemDescr.класс);

		Утверждение утверждение = ск.и(
				ск.равны(путь(корень, MorphemDescr_.тип), ТипМорфемы.СУФФИКС),
				ск.словно(путь(корень, MorphemDescr_.морфема), "%"+искомое+"%")
		);
		кз.где(утверждение);

		верни св.создайЗапрос(кз);
	}

	Строка переверни(Строка знач){
		StringBuilder сс = новый StringBuilder(знач.длина());
		символ символы[] = знач.кМассивуСимволов();
		для (цел указ = знач.длина()-1; указ >= 0; указ--){
			сс.append(символы[указ]);
		}
		верни сс.строкой();
	}

	личный статичный итоговый Строка[][] первоеСклонение = {
		{"а","я"},   {"ы","и"}, // и
		{"ы","и"},   {""}, // р
		{"е","и"},   {"ам","ям"}, // д
		{"у","ю"},   {""}, // в
		{"ой","ей"}, {"ами","ями"}, // т
		{"е","и"},   {"ах","ях"}, // п
	};

	личный статичный итоговый Строка[][] второеСклонение = {
		{"о","е",""},			{"а","я","ы","и"}, // и
		{"а","я"},   {"ов","ёв","ев","ей",""}, // р
		{"у","ю"},   {"ам","ям"}, // д
		{"о","е","","а","я"},   {"а","я","ы","и"}, // в
		{"ом","ём"}, {"ами","ями"}, // т
		{"е"},   {"ах","ях"}, // п
	};

	личный статичный итоговый Строка[][] третьеСклонение = {
		{""}, {"и"}, // и
		{"и"}, {"ей"}, // р
		{"и"},   {"ам","ям"}, // д
		{""}, {"и"}, // в
		{"ю"}, {"ами","ями"}, // т
		{"и"}, {"ах","ях"}, // п
	};

	личный статичный итоговый Строка[][][] склонения = {первоеСклонение, второеСклонение, третьеСклонение};

	личный статичный итоговый Logger ЖУРНАЛ = Logger.getLogger(Подборщик.класс.дайИмя());
}
