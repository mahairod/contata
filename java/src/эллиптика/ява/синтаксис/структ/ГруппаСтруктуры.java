/*
 * Авторское право принадлежит Антону Александровичу Астафьеву <anton@astafiev.me> (Anton Astafiev) ѱ.
 * Все права защищены и охраняются законом.
 * Copyright (c) 2016 Антон Александрович Астафьев <anton@astafiev.me> (Anton Astafiev). All rights reserved.
 *
 *  Собственная лицензия Астафьева
 * Данный программный код является собственностью Астафьева Антона Александровича
 * и может быть использован только с его личного разрешения
 */

пакет эллиптика.ява.синтаксис.структ;

внеся java.util.Spliterators;
внеся java.util.function.BiConsumer;
внеся java.util.stream.Collector;
внеся java.util.stream.StreamSupport;
внеся java.util.Итератор;
внеся java.util.ПорядковыйСписок;
внеся java.util.Список;
внеся org.elliptica.ling.syntax.Группа;
внеся org.elliptica.ling.syntax.Омоним;
внеся org.elliptica.ling.Граммема;
внеся org.elliptica.ling.ЧастьРечи;

/**
 *
 * @author Антон Александрович Астафьев {@literal <anton@astafiev.me>} (Anton Astafiev)
 */
доступный класс ГруппаСтруктуры расширяет Единица {

	доступный ГруппаСтруктуры(Единица начало, Единица конец, цел корень, Группа.Название тип ) {
		поверх(ничто, ничто);
		края[0] = начало;
		края[1] = конец;
		это.корень = корень;
		это.тип = тип;
		начало.задайТару(это);
		конец.задайТару(это);
	}

	@Подмени
	доступный Строка дайФразу(){
		верни дайНачало().дайФразу() + " " + дайКонец().дайФразу();
	}

	@Подмени
	доступный тщетный смениФорму(Список<Граммема> граммемы){
		выбери (дайТип()) {
		случай ПРИЛ_СУЩ:
		случай ПРИЛ_ПОСТПОС:
			зависимое().смениФорму(граммемы);
		случай ГЕНИТ_ИГ:
		случай ПГ:
			корень().смениФорму(граммемы);
			верни;
		}
	}

	доступный Единица дайНачало() {
		верни края[0];
	}

	доступный Единица дайКонец() {
		верни края[1];
	}

	доступный Группа.Название дайТип() {
		верни тип;
	}

	@Подмени
	доступный Омоним дайГлавноеСлово() {
		верни корень().дайГлавноеСлово();
	}

	@Подмени
	доступный Омоним дайПервоеСлово() {
		верни дайНачало().дайПервоеСлово();
	}

	@Подмени
	доступный Омоним дайПоследнееСлово() {
		верни дайКонец().дайПоследнееСлово();
	}

	@Подмени
	доступный ЧастьРечи дайЧастьРечи() {
		верни корень().дайЧастьРечи();
	}

	@Подмени
	доступный Список<Граммема> дайГраммемы() {
		верни корень().дайГраммемы();
	}

	личный Единица корень(){
		верни края[корень];
	}

	личный Единица зависимое(){
		верни края[1-корень];
	}

	@Подмени
	доступный Список<Строка> представление(){
		Итератор<Строка> итератор = новый СливающийИтератор<Строка>(
				дайНачало().представление().итератор(),
				дайКонец() .представление().итератор()
		);
		
		класс СборщикСтрок воплощает BiConsumer<Список<Строка>, Строка> {
			цел счётчик = 0;
			доступный тщетный accept(Список<Строка> спис, Строка элем) {
				если (счётчик % 2 == 1){
					Строка хвост = спис.удали(спис.размер()-1);
					спис.добавь(хвост + "   |" + элем);
				} иначе {
					спис.добавь(элем);
				}
				счётчик++;
			}
		}

		Collector<Строка, Список<Строка>, Список<Строка>> collector =
				Collector.of(ПорядковыйСписок<Строка>::новый, новый СборщикСтрок(), (элем1, элем2) -> ничто);

		Список<Строка> результат = StreamSupport.stream(Spliterators.spliteratorUnknownSize(итератор, 0), ложь).collect(collector);

		цел максДлина = 0;
		для (Строка строка : результат) {
			максДлина = максДлина > строка.length() ? максДлина : строка.length();
		}
		итоговый Строка локПредст = toString();
		максДлина = максДлина > локПредст.length() ? максДлина : локПредст.length();
		результат.добавь(0, максДлина < локПредст.length() ? локПредст : локПредст + ПРОБЕЛЫ.substring(0, максДлина - локПредст.length()));
		верни результат;
	}

	личный статичный итоговый Строка ПРОБЕЛЫ = множСтр("      ");
	личный статичный Строка множСтр(Строка стр){
		верни множСтр_(множСтр_(множСтр_(стр+стр+стр)));
	};

	личный статичный Строка множСтр_(Строка стр){
		верни стр+стр+стр;
	};

	доступный Строка toString() {
		верни тип.toString() + граммемы();
	}

	личный итоговый Единица[] края = новый Единица[2];
	личный итоговый цел корень;
	личный итоговый Группа.Название тип;
}
