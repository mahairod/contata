/*
 * Авторское право принадлежит Антону Александровичу Астафьеву <anton@astafiev.me> ѱ 2017.
 * Все права защищены и охраняются законом.
 * Copyright (c) 2017 Anton Astafiev <anton@astafiev.me>. All rights reserved.
 *
 *  Собственная лицензия Астафьева
 * Данный программный код является собственностью Астафьева Антона Александровича
 * и может быть использован только с его личного разрешения
 */

пакет эллиптика.ява.морфемика.логика;

внеся java.util.Collections;
внеся java.util.HashMap;
внеся java.util.Set;
внеся java.util.TreeSet;
внеся java.util.stream.Collectors;
внеся java.util.Коллекции;
внеся java.util.Коллекция;
внеся java.util.Массивы;
внеся java.util.Множество;
внеся java.util.МножествоСвёрток;
внеся java.util.ПорядковыйСписок;
внеся java.util.РанжированноеМножество;
внеся java.util.Словарь;
внеся java.util.Список;
внеся javax.persistence.criteria.Predicate;
внеся javax.persistence.criteria.Root;
внеся javax.persistence.metamodel.Attribute;
внеся javax.persistence.metamodel.ListAttribute;
внеся javax.persistence.metamodel.PluralAttribute;
внеся javax.persistence.metamodel.SingularAttribute;
внеся org.elliptica.ling.Граммема;
внеся org.elliptica.ling.ЧастьРечи;
внеся эллиптика.ява.морфемика.Морфема;
внеся эллиптика.ява.морфемика.ТипМорфемы;
внеся эллиптика.ява.морфемика.гл.ОтглСуффиксДействия;
внеся эллиптика.ява.морфемика.ячейки.ЗаписьМорфемы;
внеся эллиптика.ява.морфемика.ячейки.ЗаписьМорфемы_;
внеся эллиптика.ява.морфемика.ячейки.ОтношениеМорфем;
внеся эллиптика.ява.морфемика.ячейки.ТипОтношенияМорфем;
внеся эллиптика.ява.утилиты.журналирование.Журналарь;
внеся эллиптика.ява.утилиты.журналирование.Уровень;
внеся эллиптика.ява.хранение.СущностеВед;
внеся эллиптика.ява.хранение.ТипизированныйЗапрос;
внеся эллиптика.ява.хранение.ФабрикаСущностеВедов;
внеся эллиптика.ява.хранение.Хранение;
внеся эллиптика.ява.хранение.критерии.Корень;
внеся эллиптика.ява.хранение.критерии.КритериальныйЗапрос;
внеся эллиптика.ява.хранение.критерии.Путь;
внеся эллиптика.ява.хранение.критерии.СборщикКритериев;
внеся эллиптика.ява.хранение.критерии.Утверждение;
внеся статичный эллиптика.ява.хранение.метамодель.Оболочки.об;


/**
 *
 * @автор Антон Александрович Астафьев {@буквально <anton@astafiev.me>} (Anton Astafiev)
 */
доступный класс Подборщик {
	
	статичный синхронизированный доступный Подборщик экзмепляр(){
		если (подборщик == ничто){
			подборщик = новый Подборщик();
		}
		верни подборщик;
	}
	
	личный статичный Подборщик подборщик;
	личный статичный итоговый Строка гласные = "аоуэыяёюеи";
	личный статичный Строка согласные = "";

	личный итоговый СущностеВед св;
	Список<Список<Морфема>> итог;
	
	статичный {
		для (символ сим = 'а'; сим <= 'я'; сим++){
			если (гласные.номер(сим)<0){
				согласные += сим;
			}
		}
	}

	доступный Подборщик() {
		ФабрикаСущностеВедов фсв = Хранение.создайФабрикуСущностеВедов("LinguiticsPU");
		св = фсв.создайСущностеВед();
	}
	доступный статичный тщетный main(Строка[] арг){
		Подборщик генератор = новый Подборщик();
		генератор.подбери("декларативность", ЧастьРечи.существительное);
		попробуй {
			Строка суффиксы[] = {"ат", "ив", "н", "ость"};
			генератор.запуск("деклар", суффиксы);
		} ловя (ОшибкаСловообразования ош) {
			ЖУРНАЛ.запись(Уровень.ОШИБКА, ничто, ош);
		}
	}

	Строка запуск(Строка корень, Строка суффиксы[]) кидает ОшибкаСловообразования{
		Список<Морфема> слово = новый ПорядковыйСписок<>();
		слово.добавь(новый эллиптика.ява.морфемика.Корень(корень, ЧастьРечи.глагол));

		Список<? расширяет Морфема> морфемы = Массивы.списком(суффиксы).поток()
				.map(ОтглСуффиксДействия::новый).collect(Collectors.toList());

		для (Морфема морфема: морфемы){
			слово = морфема.примениК(слово);
		}
		Строка рез = слово.поток().map(м -> м.значение()).reduce("", (лев, прав) -> лев+прав);
		верни рез;
	}

	доступный Список<Список<Морфема>> подбери(Строка искомое, ЧастьРечи частьРечи, ширцел граммемы){
		исходныеГраммемы = граммемы;
		Строка основа = основа(искомое, частьРечи, Граммема.дайГраммемы(граммемы));
		верни подбери_(искомое, частьРечи, основа);
	}
	доступный Список<Список<Морфема>> подбери(Строка искомое, ЧастьРечи частьРечи, Граммема... граммемы){
		Список<Граммема> граммемСписок = Массивы.списком(граммемы);
		исходныеГраммемы = Граммема.маскаГраммем(граммемСписок);
		Строка основа = основа(искомое, частьРечи, граммемСписок);
		верни подбери_(искомое, частьРечи, основа);
	}

	личный Список<Список<Морфема>> подбери_(Строка искомое, ЧастьРечи частьРечи, Строка основа){
		исходнаяЧастьРечи = частьРечи;
		Строка ок = искомое.подстрока(основа.длина());
		ЗаписьМорфемы морфема = новый ЗаписьМорфемы(частьРечи, Буква.вНачале(ок).значение());
		Список<Вариант> вар = поиск(основа, морфема, ничто);
		итог = новый ПорядковыйСписок<>();
		для (Вариант в: вар){
			Список<Морфема> списокМорфем = новый ПорядковыйСписок<>();
			обходМорфем(в, списокМорфем, итог);
		}
		верни итог;
	}

	тщетный обходМорфем(Вариант вариант, Список<Морфема> списокМорфем, Список<Список<Морфема>> списки) {
		списокМорфем.добавь(вариант.дайЗаписьМорфемы());
		если (вариант.getДети() == ничто){
			Список<Морфема> морфемы = новый ПорядковыйСписок<>(списокМорфем);
			морфемы.добавь(вариант.дайОстаток());
			Collections.reverse(морфемы);
			списки.добавь(морфемы);
/*
			для (Морфема морфема: морфемы){
				Система.вывод.print(морфема.значение());
			}
			Система.вывод.println();
*/
		} иначе {
			для (Вариант в: вариант.getДети()){
				обходМорфем(в, списокМорфем, списки);
			}
		}
		списокМорфем.удали(вариант.дайЗаписьМорфемы());
	}

	личный цел глубина = 0;
	личный итоговый Строка ПРОБЕЛЫ = "                 ";
	личный итоговый Строка ЛЮБАЯ_МОРФЕМА = "любая";
	личный ЧастьРечи исходнаяЧастьРечи;
	личный ширцел исходныеГраммемы;

	Строка основа(Строка искомое, ЧастьРечи частьРечи, Коллекция<Граммема> граммемы){
		РанжированноеМножество<Граммема> гг = новый TreeSet<>(граммемы);
		если (частьРечи == ЧастьРечи.существительное && !граммемы.пусто()){
			цел падеж = гг.хвост(Граммема.именительный).первый().ordinal()- Граммема.именительный.ordinal();
			цел число = гг.хвост(Граммема.единственное).первый().ordinal()- Граммема.единственное.ordinal();
			для (Строка[][] скл: склонения){
			Строка [] окончания = скл[падеж*2+число];
				для (Строка ок: окончания){
					если (искомое.заканчиваетсяНа(ок)){
						верни искомое.подстрока(0, искомое.длина() - ок.длина());
					}
				}
			}
			кинь новый RuntimeException("Не нашли основу");
		} иначе {
			верни искомое;
		}
	}

	личный Список<Вариант> поиск(итоговый Строка искомое, ЗаписьМорфемы текМорфема, Строка язык){
		итоговый ЧастьРечи частьРечи = текМорфема.базоваяЧастьРечи();
		если (частьРечи == ЧастьРечи.корень){
			верни Коллекции.ПУСТОЙ_СПИСОК;
		}
		Множество<ЧастьРечи> исключения = ИСКЛЮЧЁННЫЕ_СВЯЗКИ.дай(текМорфема.целеваяЧастьРечи());
		Буква последующая = Буква.вКонце(текМорфема.getОбрат(), 'ь');

		Список<ЗаписьМорфемы> варианты = запрос(искомое, частьРечи).дайСписокРезультатов();

		Set<ОтношениеМорфем> внутрОтношения = текМорфема.дайОтношенияВнутри();
		ЗаписьМорфемы обязательная = внутрОтношения.поток()
				.filter(ом -> ом.дайОбратное()== ТипОтношенияМорфем.СТРОГОЕ)
				.map(ом -> ом.дайВнутреннюю())
				.findAny().orElse(ничто);

		глубина++;
		Список<Вариант> результат = новый ПорядковыйСписок<>(варианты.размер());
глобал:
		для (ЗаписьМорфемы морфема: варианты){
			если (обязательная!=ничто && !обязательная.равна(морфема)){
				возобнови;
			}
			если (морфема.дайТип()==ТипМорфемы.СУФФИКС && морфема.дайМорфему().заканчиваетсяНа("j") && последующая.неиз("яюеёйи")) {
				возобнови;
			}
			если (частьРечи==ЧастьРечи.любой && исключения != ничто && исключения.содержит(морфема.целеваяЧастьРечи()) ) {
				возобнови;
			}
			Set<ОтношениеМорфем> внешниеОтношения = морфема.дайОтношенияВовне();
			для (ОтношениеМорфем отношениеВне: внешниеОтношения){
				выбери (отношениеВне.дайОтношение()) {
				случай СТРОГОЕ:
					если (!текМорфема.равна(отношениеВне.дайВнешнюю())) {
						возобнови глобал;
					}
					прерви;
				случай ЗАПРЕТ:
					если (текМорфема.равна(отношениеВне.дайВнешнюю())) {
						возобнови глобал;
					} иначе если (ЛЮБАЯ_МОРФЕМА.равна(отношениеВне.дайВнешнюю().дайМорфему())) {
						возобнови глобал;
					}
				}
			}

//			вывод(морфема.строкой());
			цел длинаСуф = морфема.getОбрат().длина();
			Строка искомое_ = искомое.подстрока(0, искомое.длина() - длинаСуф);
			если (искомое_.длина() < ДЛИНЫ_ОСТАТКОВ.дайЛибоВерни(частьРечи, 3)){
				возобнови;
			}
			если (!морфема.применимаК(исходнаяЧастьРечи, исходныеГраммемы, искомое_, последующая)) {
				возобнови;
			}
			итоговый ЧастьРечи текЧастьРечи = морфема.базоваяЧастьРечи();
			если (!частьРечиСоотв(текЧастьРечи, искомое_)) {
				возобнови;
			}
			если (глубина > морфема.getМаксЛеваяПозиция()) {
				возобнови;
			}
			Строка новыйЯзык = морфема.дайЯзык();
			если (новыйЯзык != ничто) {
				// обновление
				если ("русский".равна(новыйЯзык) && язык != ничто && !новыйЯзык.равна(язык)){
					// стоп точка: с нерусского опять на русский
					возобнови;
				}
				язык = новыйЯзык;
			}
			Список<Вариант> рез = поиск(искомое_, морфема, язык);
			если (!рез.пусто()){
//				вывод("-успех!");
				результат.добавь(новый Вариант(морфема, рез));
			} иначе {
//				вывод("-неудача!");
				результат.добавь(новый Вариант(морфема, искомое_));
			}
		}
		глубина--;
		верни результат;
	}

	личный логическое частьРечиСоотв(ЧастьРечи частьРечи, Строка остаток){
		если (остаток.пуста()){
			верни ложь;
		}
		выбери (частьРечи){
			случай существительное:
				верни Буква.вКонце(остаток).из("аяьое"+согласные);
			случай любой:
			запасной:
				верни истина;
		}
	}

	личный статичный итоговый Словарь<ЧастьРечи, Множество<ЧастьРечи>> ИСКЛЮЧЁННЫЕ_СВЯЗКИ = новый HashMap<>();
	личный статичный итоговый Словарь<ЧастьРечи, Integer> ДЛИНЫ_ОСТАТКОВ = новый HashMap<>();

	статичный {
		ИСКЛЮЧЁННЫЕ_СВЯЗКИ.клади(ЧастьРечи.инфинитив,
				новый МножествоСвёрток<>(Массивы.списком(ЧастьРечи.наречие, ЧастьРечи.причастие)));

		ДЛИНЫ_ОСТАТКОВ.клади(ЧастьРечи.инфинитив, 2); // сеять
		ДЛИНЫ_ОСТАТКОВ.клади(ЧастьРечи.любой, 2); // сеять
		ДЛИНЫ_ОСТАТКОВ.клади(ЧастьРечи.глагол, 3);
		ДЛИНЫ_ОСТАТКОВ.клади(ЧастьРечи.прилагательное, 2); // ярый
	}

	личный тщетный вывод(Строка строка){
		Система.вывод.append("|");
		Система.вывод.append(ПРОБЕЛЫ, 0, 2*глубина);
		Система.вывод.println(строка);
	}

	личный ТипизированныйЗапрос<ЗаписьМорфемы> запрос(Строка искомое, ЧастьРечи частьРечи){
		СборщикКритериев ск = св.дайСборщикКритериев();
		КритериальныйЗапрос<ЗаписьМорфемы> кз = ск.создайЗапрос(ЗаписьМорфемы.класс);
		Корень<ЗаписьМорфемы> корень = кз.из(ЗаписьМорфемы.класс);

		Утверждение утверждение = частьРечи == ЧастьРечи.любой ? ск.и() :
			ск.или(
				ск.равны(путь(корень, ЗаписьМорфемы_.целевойТип), частьРечи),
				ск.равны(путь(корень,ЗаписьМорфемы_.целевойТип), ЧастьРечи.любой),
				ск.и(
					ск.равны(путь(корень,ЗаписьМорфемы_.целевойТип), ЧастьРечи.тотже),
					ск.равны(путь(корень,ЗаписьМорфемы_.исходныйТип), частьРечи)
				)
			);

		утверждение = ск.и(
				утверждение,
				ск.равны(путь(корень, ЗаписьМорфемы_.тип), ТипМорфемы.СУФФИКС),
				ск.мен(ск.длина(путь(корень, ЗаписьМорфемы_.обрат)), искомое.длина()),
				ск.равны(ск.поиск(ск.литерал(переверни(искомое)), путь(корень, ЗаписьМорфемы_.обрат)), 1)
		);
		кз.где(утверждение);

		верни св.создайЗапрос(кз);
	}
	
	личный <Ё,А> Путь<А> путь(Путь<Ё> путь, Attribute<Ё,А> attribute) {
		если (attribute экземпляр SingularAttribute) {
			SingularAttribute<Ё,А> sa = (SingularAttribute) attribute;
			верни путь.дай(об(sa));
		} иначе если (attribute экземпляр ListAttribute){
//			PluralAttribute<Ё,А,А> sa = (ListAttribute) attribute;
//			верни путь.дай(об(sa));
		}
		верни ничто;
	}

	доступный ТипизированныйЗапрос<ЗаписьМорфемы> поиск(Строка искомое){
		СборщикКритериев ск = св.дайСборщикКритериев();
		КритериальныйЗапрос<ЗаписьМорфемы> кз = ск.создайЗапрос(ЗаписьМорфемы.класс);
		Корень<ЗаписьМорфемы> корень = кз.из(ЗаписьМорфемы.класс);

		Утверждение маска;
		{
			Строка маски[] = искомое.разорви(",");
			Утверждение утвМаски[] = новый Утверждение[маски.length];
			для (цел и = 0; и < маски.length; и++){
				утвМаски[и] = ск.словно(путь(корень, ЗаписьМорфемы_.морфема), "%"+маски[и]+"%");
			}
			если (утвМаски.length > 1){
				маска = ск.или(утвМаски);
			} иначе {
				маска = утвМаски[0];
			}
		}

		Утверждение утверждение = ск.и(
				ск.равны(путь(корень, ЗаписьМорфемы_.тип), ТипМорфемы.СУФФИКС),
				ск.равны(путь(корень, ЗаписьМорфемы_.исходныйТип), ЧастьРечи.глагол),
				ск.равны(путь(корень, ЗаписьМорфемы_.целевойТип), ЧастьРечи.существительное),
				маска
		);
		кз.где(утверждение);

		верни св.создайЗапрос(кз);
	}

	Строка переверни(Строка знач){
		StringBuilder сс = новый StringBuilder(знач.длина());
		символ символы[] = знач.кМассивуСимволов();
		для (цел указ = знач.длина()-1; указ >= 0; указ--){
			сс.append(символы[указ]);
		}
		верни сс.строкой();
	}

	личный статичный итоговый Строка[][] первоеСклонение = {
		{"а","я"},   {"ы","и"}, // и
		{"ы","и"},   {""}, // р
		{"е","и"},   {"ам","ям"}, // д
		{"у","ю"},   {""}, // в
		{"ой","ей"}, {"ами","ями"}, // т
		{"е","и"},   {"ах","ях"}, // п
	};

	личный статичный итоговый Строка[][] второеСклонение = {
		{"о","е",""},			{"а","я","ы","и"}, // и
		{"а","я"},   {"ов","ёв","ев","ей",""}, // р
		{"у","ю"},   {"ам","ям"}, // д
		{"о","е","","а","я"},   {"а","я","ы","и"}, // в
		{"ом","ём"}, {"ами","ями"}, // т
		{"е"},   {"ах","ях"}, // п
	};

	личный статичный итоговый Строка[][] третьеСклонение = {
		{""}, {"и"}, // и
		{"и"}, {"ей"}, // р
		{"и"},   {"ам","ям"}, // д
		{""}, {"и"}, // в
		{"ю"}, {"ами","ями"}, // т
		{"и"}, {"ах","ях"}, // п
	};

	личный статичный итоговый Строка[][][] склонения = {первоеСклонение, второеСклонение, третьеСклонение};

	личный статичный итоговый Журналарь ЖУРНАЛ = Журналарь.дайЖурналарь(Подборщик.класс.дайИмя());
}
