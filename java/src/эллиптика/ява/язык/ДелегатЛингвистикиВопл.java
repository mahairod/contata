/*
 * Авторское право принадлежит Антону Александровичу Астафьеву <anton@astafiev.me> (Anton Astafiev) ѱ.
 * Все права защищены и охраняются законом.
 * Copyright (c) 2016-2017 Антон Александрович Астафьев <anton@astafiev.me> (Anton Astafiev). All rights reserved.
 *
 *  Собственная лицензия Астафьева
 * Данный программный код является собственностью Астафьева Антона Александровича
 * и может быть использован только с его личного разрешения
 */

пакет эллиптика.ява.язык;

внеся java.util.EnumSet;
внеся java.util.Map;
внеся java.util.TreeMap;
внеся java.util.regex.Pattern;
внеся java.util.stream.Collectors;
внеся java.util.stream.Stream;
внеся java.util.Коллекция;
внеся java.util.Массивы;
внеся java.util.Множество;
внеся java.util.МножествоСвёрток;
внеся java.util.ПорядковыйСписок;
внеся java.util.Словарь;
внеся java.util.Список;
внеся org.elliptica.ling.Morph;
внеся org.elliptica.ling.syntax.Вариант;
внеся org.elliptica.ling.syntax.Группа;
внеся org.elliptica.ling.syntax.Омоним;
внеся org.elliptica.ling.syntax.Предложение;
внеся org.elliptica.ling.syntax.Синтаксис;
внеся org.elliptica.ling.syntax.СинтаксическоеДерево;
внеся org.elliptica.ling.syntax.Слово;
внеся org.elliptica.ling.Граммема;
внеся org.elliptica.ling.ОтклонениеМорфологии;
внеся org.elliptica.ling.Парадигма;
внеся org.elliptica.ling.ТипГраммемы;
внеся org.elliptica.ling.ФормаСлова;
внеся org.elliptica.ling.ЧастьРечи;
внеся эллиптика.ява.морфология.Сложение;
внеся эллиптика.ява.морфология.Сложение.Слитность;
внеся эллиптика.ява.синтаксис.структ.ГруппаСтруктуры;
внеся эллиптика.ява.синтаксис.структ.ФабрикаСтруктуры;

/**
 *
 * @автор Антон Александрович Астафьев {@буквально <anton@astafiev.me>} (Anton Astafiev)
 */
класс ДелегатЛингвистикиВопл воплощает ДелегатЛингвистики {

	@Подмени
	доступный Строка подбериМножЧислоФразы(Строка фраза) {
		верни подбериЗаданнуюФормуФразы(фраза, Массивы.списком(Граммема.множественное));
	}

	@Подмени
	доступный Строка подбериЗаданнуюФормуФразы(Строка фраза, Коллекция<Граммема> целевыеГраммемы) {
		верни операцияНаФразе(фраза, новый ПодборФормы(новый ФормыОтНачала(целевыеГраммемы), ЧастьРечи.существительное));
	}

	@Подмени
	доступный Строка измениНаЗаданнуюФормуСлова(Строка слово, ЧастьРечи частьРечи, Коллекция<Граммема> целевыеГраммемы) {
		верни операцияНаФразе(слово, новый ПодборФормы(новый ФормыОтНачала(целевыеГраммемы), частьРечи));
	}

	@Подмени
	доступный Строка подбериНачальнуюФормуФразы(Строка фраза, Коллекция<Граммема> исходныеГраммемы) {
		верни операцияНаФразе(фраза, новый ПодборНачальнойФормы(новый ФормыКНачалу(исходныеГраммемы), ЧастьРечи.существительное));
	}

	@Подмени
	доступный Коллекция<Граммема> определиФормуФразы(Строка фраза) {
		верни операцияНаФразе(фраза, новый ОпределениеФормы());
	}

	@Подмени
	доступный Строка согласуйФормуСлова(Строка образец, Строка исходное, ЧастьРечи частьРечи) {
		Коллекция<Граммема> исходнаяФорма = определиФормуФразы(образец);
		логическое нужноЛицо = ложь;
		если (частьРечи == ЧастьРечи.глагол) {
			EnumSet<Граммема> исхНабор = EnumSet.copyOf(исходнаяФорма);
			исхНабор.оставьВсе(ГРАММЕМЫ_ЛИЦА);
			нужноЛицо = исхНабор.пусто();
		}
		Коллекция<Граммема> целеваяФорма = Stream.concat(
				нужноЛицо ? Stream.of(Граммема.третье) : Stream.empty(),
				исходнаяФорма.поток().filter(
						гр -> {
							логическое результат = ложь;
							выбери (частьРечи) {
								случай прилагательное:
								случай причастие:
								случай числительное_порядковое:
									результат = результат || гр.тип(ТипГраммемы.Падеж);
								случай глагол:
									результат = результат || гр.тип(ТипГраммемы.Число);
									результат = результат || гр.тип(ТипГраммемы.Лицо);
								случай числительное_количественное:
									результат = результат || гр.тип(ТипГраммемы.Род);
									прерви;
								запасной: верни ложь;
							}

							верни результат;
						}
				)
		)
		.collect(Collectors.toList());

		верни измениНаЗаданнуюФормуСлова(исходное, частьРечи, целеваяФорма);
	}

	личный статичный итоговый EnumSet<Граммема> ГРАММЕМЫ_ЛИЦА;
	статичный {
		Граммема.values();
		Граммема[] границы = ТипГраммемы.Лицо.границы();
		ГРАММЕМЫ_ЛИЦА = EnumSet.range(границы[0], границы[1]);
	}

	@Подмени
	доступный Строка сложноеСлово(Строка начало, Строка конец, Сложение.Характер характер, Слитность слитность) {
		символ[] начало_ = начало.кМассивуСимволов();
		если (Слитность.СОСТАВНОЕ == слитность){
			верни начало + конец;
		}
		если (Сложение.Характер.СИНТАКСИЧЕСКОЕ == характер){
			верни начало + конец;
		}

		цел послНомер = начало_.length -1;
		Строка префикс = начало.подстрока(0, послНомер);
		Строка вторПреф = начало;
		символ опредСимвол = начало_[послНомер];

		если (!('Ё'<= опредСимвол && опредСимвол <='ё')) {
			верни начало + конец;
		}
		выбери ( начало_[послНомер] ) {
			случай 'ь':
			случай 'я':
			случай 'е':
			случай 'й':
				верни префикс + "е" + конец;
			случай 'ю':
			случай 'у':
				верни начало + конец;
			случай 'а':
			случай 'о':
			случай 'ы':
			случай 'и':
				опредСимвол = начало_[послНомер-1];
				вторПреф = префикс;
			запасной:
				выбери ( опредСимвол ){
					случай 'ц':
					случай 'ч':
					случай 'ш':
					случай 'щ':
						верни вторПреф + "е" + конец;
					запасной:
						верни вторПреф + "о" + конец;
				}
		}
	}

	личный статичный сопряжение ЦелевыеФормы {
		Коллекция<Граммема> дляФразы(Коллекция<Граммема> граммемы);
	}

	статичный класс ФормыОтНачала воплощает ЦелевыеФормы {
		личный итоговый Коллекция<Граммема> целевыеГраммемы;
		личный итоговый ширцел маскаГраммем;

		доступный ФормыОтНачала(Коллекция<Граммема> целевыеГраммемы) {
			это.целевыеГраммемы = целевыеГраммемы;
			маскаГраммем = Граммема.маскаГраммем(целевыеГраммемы);
		}

		@Подмени
		доступный Коллекция<Граммема> дляФразы(Коллекция<Граммема> граммемы) {
			ширцел результат = Граммема.маскаГраммем(граммемы);

			для (ТипГраммемы типГраммемы: ТипГраммемы.values()){
				ширцел маска = маскаГраммем & типГраммемы.маска();
				если (маска == 0){
					возобнови;
				}
				результат &= ~типГраммемы.маска();
				результат |= маска;
			}
			верни Граммема.дайГраммемы(результат);
		}
	};

	статичный класс ФормыКНачалу расширяет ФормыОтНачала {
		личный итоговый Коллекция<Граммема> исходныеГраммемы;

		доступный ФормыКНачалу(Коллекция<Граммема> исходныеГраммемы) {
			поверх(начальнаяФорма(исходныеГраммемы));
			это.исходныеГраммемы = исходныеГраммемы;
		}

		доступный Коллекция<Граммема> дайИсходныеГраммемы() {
			верни исходныеГраммемы;
		}
	}

	личный статичный Коллекция<Граммема> начальнаяФорма(Коллекция<Граммема> исходныеГраммемы){
		Множество<Граммема> результат = новый МножествоСвёрток<>(исходныеГраммемы.размер());
		для (Граммема граммема: исходныеГраммемы){
			результат.добавь(граммема.тип().начальная());
		}
		верни результат;
	}

	личный сопряжение Операция<Тип> {
		Тип дляСлова(Парадигма парадигма, Строка вход) кидает ОтклонениеМорфологии;
		Тип дляФразы(ГруппаСтруктуры группаСтруктуры, Строка вход);
		запасной Строка началоФразы(){
			верни "Проверяется";
		}
		Тип дляСбоя(Строка вход);
		запасной цел рейтинг(Парадигма парадигма){
			верни (парадигма.дайЧастьРечи() == ЧастьРечи.существительное) ? 0 : 1;
		}
	}

	личный <Тип> Тип операцияНаФразе(Строка вход, Операция<Тип> операция) {
		ClassLoader oldCL = Thread.currentThread().getContextClassLoader();
		Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader());

		System.setProperty("jmorph.rml.dir", ПУТЬ_К_СЛОВАРЯМ);

		Строка[] слова = ШАБЛОН.split(вход);
		
		если (слова.length == 0){
			верни операция.дляСбоя(вход);
		}
		если (слова.length == 1){
			Словарь<Integer,Парадигма> запасныеПарадигмы = новый TreeMap<>();
			для (Парадигма парадигма: Morph.найдиСлово(слова[0]).дайПарадигмы()){
				цел рейтинг = операция.рейтинг(парадигма);
				если (рейтинг == 0){
					верни операция.дляСлова(парадигма, вход);
				} иначе {
					запасныеПарадигмы.клади(рейтинг, парадигма);
				}
			}
			если (!запасныеПарадигмы.пуст()){
				верни операция.дляСлова(запасныеПарадигмы.наборЗаписей().итератор().следующий().getValue(), вход);
			}
		}

		Строка фраза = операция.началоФразы();
		для (Строка слово : слова) {
			фраза += " " + слово.вНижнемРегистре();
		}
		
		СинтаксическоеДерево результат = дайСинтаксис().разборТекста(фраза);

		Предложение предложение = результат.getПредложения().дай(0);
		Слово слово = предложение.дайСписокСлов().дай(1);
		Омоним омоним = слово.дайОмонимы().дай(0);
		Вариант вариант = омоним.дайЮнит().родитель();
		Список<Группа> группы = вариант.дайГруппы();

		Integer[] основа = новый Integer[2];
		группы.поток().filter(группа -> группа.дайТип() == Группа.Тип.ОСНОВА).findAny().ifPresent(
			группа -> {
				основа[0] = группа.дайНачало();
				основа[1] = группа.дайКонец();
			}
		);
		
		если (основа[0] == ничто || основа[1] == ничто) {
			верни операция.дляСбоя(вход);
		}

		Список<Группа> итоговыеГруппы = группы.поток()
				.filter(гр -> гр.дайНачало() != основа[1] && гр.дайКонец() != основа[1] )
				.filter(гр -> гр.дайТип() != Группа.Тип.ФРАГМЕНТ)
				.collect(Collectors.toList());
		Список<Омоним> омонимы = вариант.дайЮниты().поток()
				.map(юнит -> юнит.дайОмоним())
				.collect(Collectors.toList());

		ГруппаСтруктуры группаСтруктуры = ФабрикаСтруктуры.создайСтруктуру(итоговыеГруппы, омонимы);
		
		Тип выход = операция.дляФразы(группаСтруктуры, вход);

		Thread.currentThread().setContextClassLoader(oldCL);

		верни выход;
	}

	личный статичный класс ПодборФормы воплощает Операция<Строка> {
		доступный ПодборФормы(ЦелевыеФормы формы, ЧастьРечи частьРечи) {
			это.формы = формы;
			это.частьРечи = частьРечи;
		}

		защищённый итоговый ЦелевыеФормы формы;
		личный итоговый ЧастьРечи частьРечи;

		@Подмени
		доступный цел рейтинг(Парадигма парадигма){
			верни парадигма.дайЧастьРечи() == частьРечи ? 0 : 1;
		}

		@Подмени
		доступный Строка дляФразы(ГруппаСтруктуры группаСтруктуры, Строка вход) {
			если (группаСтруктуры == ничто){
				верни вход;
			}

			Коллекция<Граммема> граммемы = формы.дляФразы( группаСтруктуры.дайГраммемы() );
			группаСтруктуры.смениФорму(граммемы);
			Строка выход = группаСтруктуры.дайФразу();
			если ( Character.isUpperCase(вход.символВ(0)) ){
				выход = " " + выход;
			}
			символ[] символы = выход.кМассивуСимволов();
			цел й = 0;
			для (цел и = 0; и < символы.length; и++, й++) {
				если (символы[и] == ' '){
					если (и + 1 < символы.length){
						и++;
						символы[й] = Character.toUpperCase(символы[и]);
					}
				} иначе {
					символы[й] = символы[и];
				}
			}
			верни новый Строка(символы, 0, й);
		}

		@Подмени
		доступный Строка дляСбоя(Строка вход){
			верни вход;
		}

		@Подмени
		доступный Строка дляСлова(Парадигма парадигма, Строка вход) кидает ОтклонениеМорфологии {
			ФормаСлова фс = Morph.найдиФорму(парадигма.дайБазовуюФорму(), парадигма.дайЧастьРечи(), новый МножествоСвёрток<Граммема>( формы.дляФразы(парадигма.дайГраммемы()) ));
			если (фс == ничто){
				верни вход;
			}
			Строка выход = фс.дайСлово().вНижнемРегистре();
			если ( Character.isUpperCase(вход.символВ(0)) ){
				выход = Character.toUpperCase( выход.символВ(0) ) + выход.подстрока(1);
			}
			верни выход;
		}
	}

	личный статичный класс ПодборНачальнойФормы расширяет ПодборФормы {
		личный итоговый Строка началоФразы;

		доступный ПодборНачальнойФормы(ФормыКНачалу формы, ЧастьРечи частьРечи) {
			поверх(формы, частьРечи);
			Коллекция<Граммема> исхГраммемы = формы.дайИсходныеГраммемы();
			цел маскаФорм = (цел) (МАСКА_ИЗМЕНЯЕМЫХ_ГРАММЕМ & Граммема.маскаГраммем(исхГраммемы));
			если (частьРечи == ЧастьРечи.существительное){
				маскаФорм &= ТипГраммемы.Число.маска() | ТипГраммемы.Падеж.маска();
				если (исхГраммемы.содержит(Граммема.именительный)){
					если (исхГраммемы.содержит(Граммема.множественное)) {
						началоФразы = "Проверяются";
					} иначе {
						началоФразы = поверх.началоФразы();
					}
				} иначе {
					ширцел падМаска = маскаФорм & ТипГраммемы.Падеж.маска();
					цел номер = Long.numberOfTrailingZeros(падМаска);
					началоФразы = КЛЮЧИ[номер - СМЕЩ_КЛ];
				}
			} иначе {
				началоФразы = поверх.началоФразы();
			}
		}

		личный статичный итоговый Строка[] КЛЮЧИ = новый Строка[]{"Не существет", "Я даю", "Я вижу", "Я доволен", "Я думаю о"};
		личный статичный итоговый цел СМЕЩ_КЛ = 1 + Long.numberOfTrailingZeros(ТипГраммемы.Падеж.начальная().маска());

		личный статичный цел МАСКА_ИЗМЕНЯЕМЫХ_ГРАММЕМ = 0;
		статичный {
			ТипГраммемы [] типы = ТипГраммемы.values();
			для (цел тип = 1; тип <= ТипГраммемы.Лицо.ordinal(); тип++){
				МАСКА_ИЗМЕНЯЕМЫХ_ГРАММЕМ |= типы[тип].маска();
			}
		}

		@Подмени
		доступный цел рейтинг(Парадигма парадигма) {
			цел рейтинг = поверх.рейтинг(парадигма) * 100;
			ФормыКНачалу формыКНачалу = (ФормыКНачалу) формы;
			ширцел исхМаска = Граммема.маскаГраммем(формыКНачалу.дайИсходныеГраммемы());
			ширцел текМаска = Граммема.маскаГраммем(парадигма.дайГраммемы());
			ширцел провМаска = текМаска & исхМаска;
			цел разница = Long.bitCount(исхМаска) - Long.bitCount(провМаска);
			верни рейтинг + разница * 10;
		}



		@Подмени
		доступный Строка началоФразы() {
			верни началоФразы;
		}

	}

	личный класс ОпределениеФормы воплощает Операция<Коллекция<Граммема>> {

		@Подмени
		доступный Коллекция<Граммема> дляСлова(Парадигма парадигма, Строка вход) кидает ОтклонениеМорфологии {
			верни парадигма.дайГраммемы();
		}

		@Подмени
		доступный Коллекция<Граммема> дляФразы(ГруппаСтруктуры группаСтруктуры, Строка вход) {
			верни группаСтруктуры.дайГраммемы();
		}

		@Подмени
		доступный Коллекция<Граммема> дляСбоя(Строка вход) {
			кинь новый NullPointerException();
		}

		@Подмени
		доступный цел рейтинг(Парадигма парадигма){
			цел рейтинг = Операция.поверх.рейтинг(парадигма) * 100;
			Множество<Граммема> граммемы = парадигма.дайГраммемы();
			выбери (парадигма.дайЧастьРечи()){
				случай прилагательное:
				случай причастие:
				случай местоименное_прилагательное:
					рейтинг += граммемы.содержит(Граммема.мужской) ? 0 : 10;
				случай существительное:
				случай местоименное_существительное:
					рейтинг += граммемы.содержит(Граммема.именительный) ? 0 : 6;
					рейтинг += граммемы.содержит(Граммема.единственное) ? 0 : 3;
			}
			верни рейтинг;
		}

	}
	личный статичный Граммема[] МАССИВ_ГРАММЕМ = новый Граммема[0];

	личный статичный Синтаксис дайСинтаксис(){
		если (ничто == синтаксис)  {
			синтаксис = новый Синтаксис(ПУТЬ_К_СЛОВАРЯМ);
		}
		верни синтаксис;
	}

	личный статичный итоговый Строка РАЗДЕЛИТЕЛЬ = "(?=[А-ЯЁ][а-яё]*($|[А-ЯЁ]))";
	личный статичный итоговый Pattern ШАБЛОН = Pattern.compile(РАЗДЕЛИТЕЛЬ);

	личный статичный итоговый Строка ПУТЬ_К_СЛОВАРЯМ = "/mnt/f16/mahairod/Develop/cpp/linguistan/";
	личный статичный Синтаксис синтаксис;


}
