/*
 * Авторское право принадлежит Антону Александровичу Астафьеву <anton@astafiev.me> ѱ 2017.
 * Все права защищены и охраняются законом.
 * Copyright (c) 2017 Anton Astafiev <anton@astafiev.me>. All rights reserved.
 *
 *  Собственная лицензия Астафьева
 * Данный программный код является собственностью Астафьева Антона Александровича
 * и может быть использован только с его личного разрешения
 */

пакет эллиптика.ява.морфемика.логика;

внеся java.util.БегунокСписка;
внеся java.util.Итератор;
внеся java.util.Итерируемое;
внеся java.util.Коллекции;
внеся java.util.ПорядковыйСписок;
внеся java.util.Словарь;
внеся java.util.Список;
внеся java.util.ТаблицаСвёрток;
внеся org.elliptica.ling.Morph;
внеся org.elliptica.ling.Граммема;
внеся org.elliptica.ling.Парадигма;
внеся org.elliptica.ling.РезультатСлова;
внеся org.elliptica.ling.ЧастьРечи;
внеся эллиптика.ява.морфемика.Морфема;
внеся статичный эллиптика.ява.морфемика.логика.Разбор.Состояние.*;
внеся эллиптика.ява.морфемика.ТипМорфемы;
внеся эллиптика.ява.морфемика.ячейки.ЗаписьМорфемы;
внеся эллиптика.ява.утилиты.ОбратноеПробегаемое;


/**
 *
 * @автор Антон Александрович Астафьев {@буквально <anton@astafiev.me>} (Anton Astafiev)
 */
доступный класс Разбор {

	доступный статичный логическое отглагольноеЛиИмя(Строка строка, ЧастьРечи частьРечи, ширцел маска_граммем) {
		если (частьРечи != ЧастьРечи.существительное){
			верни ложь;
		}
		Подборщик подборщик = Подборщик.экзмепляр();
		Список<Список<Морфема>> варианты = подборщик.подбери(строка, частьРечи, маска_граммем);
		для (Список<Морфема> структура: варианты){
			ЧастьРечи текЧР = ничто;
			для (Морфема морф:  обратно(структура)){
				если (морф.дайТип() != ТипМорфемы.СУФФИКС){
					прерви;
				}
				если (цельСовместима(ЧастьРечи.существительное, морф)){
					если (морф.базоваяЧастьРечи() == ЧастьРечи.глагол){
						верни истина;
					}
					возобнови;
				}
				если (цельСовместима(ЧастьРечи.глагол, морф)){
					текЧР = ЧастьРечи.глагол;
				}
				прерви;
			}
			если (текЧР == ЧастьРечи.глагол){
				верни истина;
			}
		}
		верни ложь;
	}

	доступный статичный логическое цельСовместима(ЧастьРечи цель, Морфема м){
		если (цель == м.целеваяЧастьРечи() || цель == ЧастьРечи.любой){
			верни истина;
		}
		если (м.целеваяЧастьРечи() == ЧастьРечи.тотже && (цель == м.базоваяЧастьРечи() || м.базоваяЧастьРечи() == ЧастьРечи.любой)){
			верни истина;
		}
		верни ложь;
	}

	доступный логическое исходникСовместим(ЧастьРечи исходник, Морфема м){
		верни исходник == м.базоваяЧастьРечи() || исходник == ЧастьРечи.любой;
	}

	доступный Строка отглагольноеИмя(Строка строка, ЧастьРечи частьРечи) {
		если (частьРечи != ЧастьРечи.инфинитив){
			верни ничто;
		}
		Подборщик подборщик = Подборщик.экзмепляр();
		Список<Список<Морфема>> варианты = подборщик.подбери(строка, частьРечи, 0);
		Строка результат = ничто;
верх:
		для (Список<Морфема> структура: варианты){
			Состояние состояние = ИНФИНИТИВ;
			для (цел и = структура.размер()-1; и >= 0; и-- ){
				Морфема морф = структура.дай(и);
				если (! (морф экземпляр ЗаписьМорфемы) ) {
					возобнови;
				}
				ЗаписьМорфемы зм = (ЗаписьМорфемы) морф;
				Состояние след = состояния.дай(зм.дайРазл());
				выбери (состояние) {
					случай ИНФИНИТИВ:
						если (след == ОСНОВА) {
							состояние = след;
							возобнови;
						} иначе если (след == ПРЕДОСНОВА) {
							состояние = след;
							Строка рез = подборКонцовки(структура.подСписок(0, и), "ениj", "с-д");
							если (рез != ничто) {
								верни рез;
							}
							возобнови;
						} иначе {
							состояние = ОШИБКА;
							прерви верх;
						}
					случай ОСНОВА:
						состояние = след;
						если (след == ПРЕДОСНОВА) {
							Строка рез = подборКонцовки(структура.подСписок(0, и+1), "ниj");
							если (рез != ничто) {
								верни рез;
							}
							возобнови;
						} иначе если (след == ПРЕДОСНОВА_Я) {
							Строка рез = подборКонцовки(структура.подСписок(0, и+1), "ниj,тиj");
							если (рез != ничто) {
								верни рез;
							}
							возобнови;
						} иначе если (след == ПРЕДОСНОВА_И) {
							Строка рез = подборКонцовки(структура.подСписок(0, и), "ениj");
							если (рез != ничто) {
								верни рез;
							}
							возобнови;
						} иначе {
							состояние = ОШИБКА;
							прерви;
						}
				}
			}
			если (состояние == ГОТОВО) {
				прерви;
			}
		}
		верни результат;
	}

	личный Строка подборКонцовки(Список<Морфема> начальные, Строка маска, Строка... чередования) {
		Список<ЗаписьМорфемы> суффиксы = Подборщик.экзмепляр().поиск(маска).дайСписокРезультатов();
		StringBuilder начало = новый StringBuilder();
		для (Морфема морфема: начальные){
			начало.append(морфема.значение());
		}
		Список<Строка> замены = новый ПорядковыйСписок<>(1+чередования.length);
		Коллекции.добавьВсе(замены, (Строка) ничто);
		Коллекции.добавьВсе(замены, чередования);
		для (Строка замена: замены){
			Строка старт = начало.строкой();
			если (замена != ничто){
				Строка[] шаблоны = замена.разорви("-");
				если (!старт.заканчиваетсяНа(шаблоны[0])){
					возобнови;
				}
				старт = старт.подстрока(0, старт.длина()-шаблоны[0].длина()) + шаблоны[1];
			}
			для (ЗаписьМорфемы суффикс: суффиксы) {
				Строка вариант = старт + суффикс.значение().замени('j', 'е');
				РезультатСлова результатСлова = Morph.найдиСлово(вариант);
				для (Парадигма парадигма: результатСлова.дайПарадигмы()){
					если (парадигма.былоНайдено() && парадигма.дайЧастьРечи() == ЧастьРечи.существительное){
						верни вариант;
					}
				}
			}
		}
		верни ничто;
	}
	
	личный статичный Итерируемое<Морфема> обратно(Список<Морфема> список){
		верни новый ОбратноеПробегаемое<>(список);
	}
	
	личный статичный итоговый Словарь<Integer, Состояние> состояния;
	статичный {
		состояния = новый ТаблицаСвёрток<>(5);
		состояния.клади(1151, ПРЕДОСНОВА);
		состояния.клади(1180, ОСНОВА);
		состояния.клади(1665, ПРЕДОСНОВА);
		состояния.клади(1666, ПРЕДОСНОВА_Я);
		состояния.клади(1084, ПРЕДОСНОВА_И);
	}

	статичный переч Состояние {
		ИНФИНИТИВ, ОСНОВА, ПРЕДОСНОВА, ПРЕДОСНОВА_И, ПРЕДОСНОВА_Я, КОРЕНЬ, ГОТОВО, ОШИБКА
	}
	
}
