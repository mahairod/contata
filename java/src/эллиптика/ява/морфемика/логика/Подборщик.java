/*
 * Авторское право принадлежит Антону Александровичу Астафьеву <anton@astafiev.me> ѱ 2017.
 * Все права защищены и охраняются законом.
 * Copyright (c) 2017 Anton Astafiev <anton@astafiev.me>. All rights reserved.
 *
 *  Собственная лицензия Астафьева
 * Данный программный код является собственностью Астафьева Антона Александровича
 * и может быть использован только с его личного разрешения
 */

пакет эллиптика.ява.морфемика.логика;

внеся java.util.Collections;
внеся java.util.HashMap;
внеся java.util.TreeSet;
внеся java.util.logging.Level;
внеся java.util.logging.Logger;
внеся java.util.stream.Collectors;
внеся java.util.Коллекции;
внеся java.util.Коллекция;
внеся java.util.Массивы;
внеся java.util.Множество;
внеся java.util.МножествоСвёрток;
внеся java.util.ПорядковыйСписок;
внеся java.util.РанжированноеМножество;
внеся java.util.Словарь;
внеся java.util.Список;
внеся javax.persistence.criteria.Predicate;
внеся javax.persistence.criteria.Root;
внеся javax.persistence.metamodel.Attribute;
внеся javax.persistence.metamodel.ListAttribute;
внеся javax.persistence.metamodel.PluralAttribute;
внеся javax.persistence.metamodel.SingularAttribute;
внеся org.elliptica.ling.Граммема;
внеся org.elliptica.ling.ЧастьРечи;
внеся эллиптика.ява.морфемика.Морфема;
внеся эллиптика.ява.морфемика.ТипМорфемы;
внеся эллиптика.ява.морфемика.гл.ОтглСуффиксДействия;
внеся эллиптика.ява.морфемика.ячейки.ЗаписьМорфемы;
внеся эллиптика.ява.морфемика.ячейки.ЗаписьМорфемы_;
внеся эллиптика.ява.хранение.СущностеВед;
внеся эллиптика.ява.хранение.ТипизированныйЗапрос;
внеся эллиптика.ява.хранение.ФабрикаСущностеВедов;
внеся эллиптика.ява.хранение.Хранение;
внеся эллиптика.ява.хранение.критерии.Корень;
внеся эллиптика.ява.хранение.критерии.КритериальныйЗапрос;
внеся эллиптика.ява.хранение.критерии.Путь;
внеся эллиптика.ява.хранение.критерии.СборщикКритериев;
внеся эллиптика.ява.хранение.критерии.Утверждение;
внеся статичный эллиптика.ява.хранение.метамодель.Оболочки.об;


/**
 *
 * @автор Антон Александрович Астафьев {@буквально <anton@astafiev.me>} (Anton Astafiev)
 */
доступный класс Подборщик {
	
	статичный синхронизированный доступный Подборщик экзмепляр(){
		если (подборщик == ничто){
			подборщик = новый Подборщик();
		}
		верни подборщик;
	}
	
	личный статичный Подборщик подборщик;

	личный итоговый СущностеВед св;
	личный итоговый Строка гласные = "аоуэыяёюеи";
	личный Строка согласные = "";
	Список<Список<Морфема>> итог;

	доступный Подборщик() {
		ФабрикаСущностеВедов фсв = Хранение.создайФабрикуСущностеВедов("LinguiticsPU");
		св = фсв.создайСущностеВед();

		согласные = "";
		для (символ сим = 'а'; сим <= 'я'; сим++){
			если (гласные.номер(сим)<0){
				согласные += сим;
			}
		}

	}
	доступный статичный тщетный main(Строка[] арг){
		Подборщик генератор = новый Подборщик();
		генератор.подбери("декларативность", ЧастьРечи.существительное);
		попробуй {
			Строка суффиксы[] = {"ат", "ив", "н", "ость"};
			генератор.запуск("деклар", суффиксы);
		} ловя (ОшибкаСловообразования ош) {
			ЖУРНАЛ.log(Level.SEVERE, ничто, ош);
		}
	}

	Строка запуск(Строка корень, Строка суффиксы[]) кидает ОшибкаСловообразования{
		Список<Морфема> слово = новый ПорядковыйСписок<>();
		слово.добавь(новый эллиптика.ява.морфемика.Корень(корень, ЧастьРечи.глагол));

		Список<? расширяет Морфема> морфемы = Массивы.списком(суффиксы).поток()
				.map(ОтглСуффиксДействия::новый).collect(Collectors.toList());

		для (Морфема морфема: морфемы){
			слово = морфема.примениК(слово);
		}
		Строка рез = слово.поток().map(м -> м.значение()).reduce("", (лев, прав) -> лев+прав);
		верни рез;
	}

	доступный Список<Список<Морфема>> подбери(Строка искомое, ЧастьРечи частьРечи, ширцел граммемы){
		исходныеГраммемы = граммемы;
		Строка основа = основа(искомое, частьРечи, Граммема.дайГраммемы(граммемы));
		верни подбери_(искомое, частьРечи, основа);
	}
	доступный Список<Список<Морфема>> подбери(Строка искомое, ЧастьРечи частьРечи, Граммема... граммемы){
		Список<Граммема> граммемСписок = Массивы.списком(граммемы);
		исходныеГраммемы = Граммема.маскаГраммем(граммемСписок);
		Строка основа = основа(искомое, частьРечи, граммемСписок);
		верни подбери_(искомое, частьРечи, основа);
	}

	личный Список<Список<Морфема>> подбери_(Строка искомое, ЧастьРечи частьРечи, Строка основа){
		исходнаяЧастьРечи = частьРечи;
		Строка ок = искомое.подстрока(основа.длина());
		Список<Вариант> вар = поиск(основа, частьРечи, ничто, Буква.начало(ок), ничто);
		итог = новый ПорядковыйСписок<>();
		для (Вариант в: вар){
			Список<Морфема> списокМорфем = новый ПорядковыйСписок<>();
			обходМорфем(в, списокМорфем, итог);
		}
		верни итог;
	}

	тщетный обходМорфем(Вариант вариант, Список<Морфема> списокМорфем, Список<Список<Морфема>> списки) {
		списокМорфем.добавь(вариант.дайЗаписьМорфемы());
		если (вариант.getДети() == ничто){
			Список<Морфема> морфемы = новый ПорядковыйСписок<>(списокМорфем);
			морфемы.добавь(вариант.дайОстаток());
			Collections.reverse(морфемы);
			списки.добавь(морфемы);
/*
			для (Морфема морфема: морфемы){
				Система.вывод.print(морфема.значение());
			}
			Система.вывод.println();
*/
		} иначе {
			для (Вариант в: вариант.getДети()){
				обходМорфем(в, списокМорфем, списки);
			}
		}
		списокМорфем.удали(вариант.дайЗаписьМорфемы());
	}

	личный цел глубина = 0;
	личный итоговый Строка ПРОБЕЛЫ = "                 ";
	личный ЧастьРечи исходнаяЧастьРечи;
	личный ширцел исходныеГраммемы;

	Строка основа(Строка искомое, ЧастьРечи частьРечи, Коллекция<Граммема> граммемы){
		РанжированноеМножество<Граммема> гг = новый TreeSet<>(граммемы);
		если (частьРечи == ЧастьРечи.существительное && !граммемы.пусто()){
			цел падеж = гг.хвост(Граммема.именительный).первый().ordinal()- Граммема.именительный.ordinal();
			цел число = гг.хвост(Граммема.единственное).первый().ordinal()- Граммема.единственное.ordinal();
			для (Строка[][] скл: склонения){
			Строка [] окончания = скл[падеж*2+число];
				для (Строка ок: окончания){
					если (искомое.заканчиваетсяНа(ок)){
						верни искомое.подстрока(0, искомое.длина() - ок.длина());
					}
				}
			}
			кинь новый RuntimeException("Не нашли основу");
		} иначе {
			верни искомое;
		}
	}

	личный Список<Вариант> поиск(итоговый Строка искомое, итоговый ЧастьРечи частьРечи, Множество<ЧастьРечи> исключения, Буква последующий, Строка язык){
		если (частьРечи == ЧастьРечи.корень){
			верни Коллекции.ПУСТОЙ_СПИСОК;
		}
		Список<ЗаписьМорфемы> варианты = запрос(искомое, частьРечи).дайСписокРезультатов();
		глубина++;
		Список<Вариант> результат = новый ПорядковыйСписок<>(варианты.размер());
		для (ЗаписьМорфемы морфема: варианты){
			если (морфема.дайТип()==ТипМорфемы.СУФФИКС && морфема.дайМорфему().заканчиваетсяНа("j") && последующий.неиз("яюеёй")) {
				возобнови;
			}
			если (частьРечи==ЧастьРечи.любой && исключения != ничто && исключения.содержит(морфема.целеваяЧастьРечи()) ) {
				возобнови;
			}
//			вывод(морфема.строкой());
			цел длинаСуф = морфема.getОбрат().длина();
			Строка искомое_ = искомое.подстрока(0, искомое.длина() - длинаСуф);
			если (искомое_.длина() < ДЛИНЫ_ОСТАТКОВ.дайЛибоВерни(частьРечи, 3)){
				возобнови;
			}
			если (!морфема.применимаК(исходнаяЧастьРечи, исходныеГраммемы, искомое_, последующий)) {
				возобнови;
			}
			итоговый ЧастьРечи текЧастьРечи = морфема.базоваяЧастьРечи();
			если (!частьРечиСоотв(текЧастьРечи, искомое_)) {
				возобнови;
			}
			если (глубина > морфема.getМаксЛеваяПозиция()) {
				возобнови;
			}
			Строка новыйЯзык = морфема.дайЯзык();
			если (новыйЯзык != ничто) {
				// обновление
				если ("русский".равна(новыйЯзык) && язык != ничто && !новыйЯзык.равна(язык)){
					// стоп точка: с нерусского опять на русский
					возобнови;
				}
				язык = новыйЯзык;
			}
			Список<Вариант> рез = поиск(искомое_, текЧастьРечи, ИСКЛЮЧЁННЫЕ_СВЯЗКИ.дай(морфема.целеваяЧастьРечи()), Буква.конец(морфема.getОбрат(), 'ь'), язык);
			если (!рез.пусто()){
//				вывод("-успех!");
				результат.добавь(новый Вариант(морфема, рез));
			} иначе {
//				вывод("-неудача!");
				результат.добавь(новый Вариант(морфема, искомое_));
			}
		}
		глубина--;
		верни результат;
	}

	личный логическое частьРечиСоотв(ЧастьРечи частьРечи, Строка остаток){
		если (остаток.пуста()){
			верни ложь;
		}
		выбери (частьРечи){
			случай существительное:
				верни Буква.конец(остаток).из("аяьое"+согласные);
			случай любой:
			запасной:
				верни истина;
		}
	}

	личный статичный итоговый Словарь<ЧастьРечи, Множество<ЧастьРечи>> ИСКЛЮЧЁННЫЕ_СВЯЗКИ = новый HashMap<>();
	личный статичный итоговый Словарь<ЧастьРечи, Integer> ДЛИНЫ_ОСТАТКОВ = новый HashMap<>();

	статичный {
		ИСКЛЮЧЁННЫЕ_СВЯЗКИ.клади(ЧастьРечи.инфинитив,
				новый МножествоСвёрток<>(Массивы.списком(ЧастьРечи.наречие, ЧастьРечи.причастие)));

		ДЛИНЫ_ОСТАТКОВ.клади(ЧастьРечи.инфинитив, 2); // сеять
		ДЛИНЫ_ОСТАТКОВ.клади(ЧастьРечи.любой, 2); // сеять
		ДЛИНЫ_ОСТАТКОВ.клади(ЧастьРечи.глагол, 3);
		ДЛИНЫ_ОСТАТКОВ.клади(ЧастьРечи.прилагательное, 2); // ярый
	}

	личный тщетный вывод(Строка строка){
		Система.вывод.append("|");
		Система.вывод.append(ПРОБЕЛЫ, 0, 2*глубина);
		Система.вывод.println(строка);
	}

	личный ТипизированныйЗапрос<ЗаписьМорфемы> запрос(Строка искомое, ЧастьРечи частьРечи){
		СборщикКритериев ск = св.дайСборщикКритериев();
		КритериальныйЗапрос<ЗаписьМорфемы> кз = ск.создайЗапрос(ЗаписьМорфемы.класс);
		Корень<ЗаписьМорфемы> корень = кз.из(ЗаписьМорфемы.класс);

		Утверждение утверждение = частьРечи == ЧастьРечи.любой ? ск.и() :
			ск.или(
				ск.равны(путь(корень, ЗаписьМорфемы_.целевойТип), частьРечи),
				ск.равны(путь(корень,ЗаписьМорфемы_.целевойТип), ЧастьРечи.любой),
				ск.и(
					ск.равны(путь(корень,ЗаписьМорфемы_.целевойТип), ЧастьРечи.тотже),
					ск.равны(путь(корень,ЗаписьМорфемы_.исходныйТип), частьРечи)
				)
			);

		утверждение = ск.и(
				утверждение,
				ск.равны(путь(корень, ЗаписьМорфемы_.тип), ТипМорфемы.СУФФИКС),
				ск.мен(ск.длина(путь(корень, ЗаписьМорфемы_.обрат)), искомое.длина()),
				ск.равны(ск.поиск(ск.литерал(переверни(искомое)), путь(корень, ЗаписьМорфемы_.обрат)), 1)
		);
		кз.где(утверждение);

		верни св.создайЗапрос(кз);
	}
	
	личный <Ё,А> Путь<А> путь(Путь<Ё> путь, Attribute<Ё,А> attribute) {
		если (attribute экземпляр SingularAttribute) {
			SingularAttribute<Ё,А> sa = (SingularAttribute) attribute;
			верни путь.дай(об(sa));
		} иначе если (attribute экземпляр ListAttribute){
//			PluralAttribute<Ё,А,А> sa = (ListAttribute) attribute;
//			верни путь.дай(об(sa));
		}
		верни ничто;
	}

	доступный ТипизированныйЗапрос<ЗаписьМорфемы> поиск(Строка искомое){
		СборщикКритериев ск = св.дайСборщикКритериев();
		КритериальныйЗапрос<ЗаписьМорфемы> кз = ск.создайЗапрос(ЗаписьМорфемы.класс);
		Корень<ЗаписьМорфемы> корень = кз.из(ЗаписьМорфемы.класс);

		Утверждение маска;
		{
			Строка маски[] = искомое.разорви(",");
			Утверждение утвМаски[] = новый Утверждение[маски.length];
			для (цел и = 0; и < маски.length; и++){
				утвМаски[и] = ск.словно(путь(корень, ЗаписьМорфемы_.морфема), "%"+маски[и]+"%");
			}
			если (утвМаски.length > 1){
				маска = ск.или(утвМаски);
			} иначе {
				маска = утвМаски[0];
			}
		}

		Утверждение утверждение = ск.и(
				ск.равны(путь(корень, ЗаписьМорфемы_.тип), ТипМорфемы.СУФФИКС),
				ск.равны(путь(корень, ЗаписьМорфемы_.исходныйТип), ЧастьРечи.глагол),
				ск.равны(путь(корень, ЗаписьМорфемы_.целевойТип), ЧастьРечи.существительное),
				маска
		);
		кз.где(утверждение);

		верни св.создайЗапрос(кз);
	}

	Строка переверни(Строка знач){
		StringBuilder сс = новый StringBuilder(знач.длина());
		символ символы[] = знач.кМассивуСимволов();
		для (цел указ = знач.длина()-1; указ >= 0; указ--){
			сс.append(символы[указ]);
		}
		верни сс.строкой();
	}

	личный статичный итоговый Строка[][] первоеСклонение = {
		{"а","я"},   {"ы","и"}, // и
		{"ы","и"},   {""}, // р
		{"е","и"},   {"ам","ям"}, // д
		{"у","ю"},   {""}, // в
		{"ой","ей"}, {"ами","ями"}, // т
		{"е","и"},   {"ах","ях"}, // п
	};

	личный статичный итоговый Строка[][] второеСклонение = {
		{"о","е",""},			{"а","я","ы","и"}, // и
		{"а","я"},   {"ов","ёв","ев","ей",""}, // р
		{"у","ю"},   {"ам","ям"}, // д
		{"о","е","","а","я"},   {"а","я","ы","и"}, // в
		{"ом","ём"}, {"ами","ями"}, // т
		{"е"},   {"ах","ях"}, // п
	};

	личный статичный итоговый Строка[][] третьеСклонение = {
		{""}, {"и"}, // и
		{"и"}, {"ей"}, // р
		{"и"},   {"ам","ям"}, // д
		{""}, {"и"}, // в
		{"ю"}, {"ами","ями"}, // т
		{"и"}, {"ах","ях"}, // п
	};

	личный статичный итоговый Строка[][][] склонения = {первоеСклонение, второеСклонение, третьеСклонение};

	личный статичный итоговый Logger ЖУРНАЛ = Logger.getLogger(Подборщик.класс.дайИмя());
}
