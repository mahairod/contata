/*
 * Авторское право принадлежит Антону Александровичу Астафьеву <anton@astafiev.me> ѱ 2017.
 * Все права защищены и охраняются законом.
 * Copyright (c) 2017 Anton Astafiev <anton@astafiev.me>. All rights reserved.
 *
 *  Собственная лицензия Астафьева
 * Данный программный код является собственностью Астафьева Антона Александровича
 * и может быть использован только с его личного разрешения
 */

пакет эллиптика.ява.морфемика;

внеся java.util.logging.Level;
внеся java.util.logging.Logger;
внеся java.util.stream.Collectors;
внеся java.util.Массивы;
внеся java.util.ПорядковыйСписок;
внеся java.util.Список;
внеся javax.persistence.criteria.Predicate;
внеся javax.persistence.criteria.Root;
внеся org.elliptica.ling.ЧастьРечи;
внеся эллиптика.ява.морфемика.гл.ОтглСуффиксДействия;
внеся эллиптика.ява.морфемика.ячейки.MorphemDescr;
внеся эллиптика.ява.морфемика.ячейки.MorphemDescr_;
внеся эллиптика.ява.хранение.СущностеВед;
внеся эллиптика.ява.хранение.ТипизированныйЗапрос;
внеся эллиптика.ява.хранение.ФабрикаСущностеВедов;
внеся эллиптика.ява.хранение.Хранение;
внеся эллиптика.ява.хранение.критерии.КритериальныйЗапрос;
внеся эллиптика.ява.хранение.критерии.СборщикКритериев;


/**
 *
 * @автор Антон Александрович Астафьев {@буквально <anton@astafiev.me>} (Anton Astafiev)
 */
доступный класс Генератор {
	доступный статичный тщетный main(Строка[] арг){
		Генератор генератор = новый Генератор();
		генератор.запускСБазой();
		попробуй {
			Строка суффиксы[] = {"ат", "ив", "н", "ость"};
			генератор.запуск("деклар", суффиксы);
		} ловя (ОшибкаСловообразования ош) {
			ЖУРНАЛ.log(Level.SEVERE, ничто, ош);
		}
	}

	доступный Строка запуск(Строка корень, Строка суффиксы[]) кидает ОшибкаСловообразования{
		Список<Морфема> слово = новый ПорядковыйСписок<>();
		слово.добавь(новый Корень(корень, ЧастьРечи.глагол));

		Список<? расширяет Морфема> морфемы = Массивы.списком(суффиксы).поток()
				.map(ОтглСуффиксДействия::новый).collect(Collectors.toList());

		для (Морфема морфема: морфемы){
			слово = морфема.примениК(слово);
		}
		Строка рез = слово.поток().map(м -> м.значение()).reduce("", (лев, прав) -> лев+прав);
		верни рез;
	}


	СущностеВед св;
	Строка гласные = "аоуэыяёюеи";
	Строка согласные = "";

	доступный Строка запускСБазой(){
		ФабрикаСущностеВедов фсв = Хранение.создайФабрикуСущностеВедов("LinguiticsPU");
		св = фсв.создайСущностеВед();

		гласные = "аоуэыяёюеи";
		согласные = "";
		цел согласМаска = 0;
		для (символ сим = 'а'; сим <= 'я'; сим++){
			если (гласные.номер(сим)<0){
				согласные += сим;
				согласМаска |= (1 << (сим-'а'));
			}
		}

		ЧастьРечи частьРечи = ЧастьРечи.существительное;
		Строка искомое = "декларативность";

		исходнаяЧастьРечи = частьРечи;
		поиск(искомое, частьРечи, '∅', ничто);
		верни ничто;
	}

	личный цел глубина = 0;
	личный итоговый Строка ПРОБЕЛЫ = "                 ";
	ЧастьРечи исходнаяЧастьРечи;

	личный Список<MorphemDescr> поиск(итоговый Строка искомое, ЧастьРечи частьРечи, символ последующий, Строка язык){
		Список<MorphemDescr> варианты = запрос(искомое, частьРечи).getResultList();
		глубина++;
		для (MorphemDescr морфема: варианты){
			если (морфема.дайТип()==ТипМорфемы.СУФФИКС && морфема.дайМорфему().заканчиваетсяНа("j") && "яюеёй".номер(последующий)<0) {
				возобнови;
			}
			вывод(морфема.строкой());
			цел длинаСуф = морфема.getОбрат().длина();
			Строка искомое_ = искомое.подстрока(0, искомое.длина() - длинаСуф);
			если (!морфема.применимаК(исходнаяЧастьРечи, искомое_, последующий)) {
				возобнови;
			}
			если (!частьРечиСоотв(частьРечи, искомое_)) {
				возобнови;
			}
			если (глубина-1 > морфема.getМаксЛеваяПозиция()) {
				возобнови;
			}
			Строка новыйЯзык = морфема.дайЯзык();
			если (новыйЯзык != ничто) {
				// обновление
				если ("русский".равна(новыйЯзык) && !новыйЯзык.равна(язык)){
					// стоп точка
					возобнови;
				}
				язык = морфема.дайЯзык();
			}
			частьРечи = морфема.дайИсходныйТип();
			символ начало = морфема.getОбрат().символВ(длинаСуф-1);
			Список<MorphemDescr> результат = поиск(искомое_, частьРечи, начало, язык);
			если (!результат.пусто()){
				вывод("-успех!");
				верни результат;
			} иначе {
				вывод("-неудача!");
			}
		}
		глубина--;
		верни новый ПорядковыйСписок<>();
	}

	личный логическое частьРечиСоотв(ЧастьРечи частьРечи, Строка остаток){
		если (остаток.пуста()){
			верни ложь;
		}
		символ конец = остаток.символВ(остаток.длина()-1);
		выбери (частьРечи){
			случай существительное:
				верни ("аяьое"+согласные).номер(конец)>=0;
			запасной:
				верни истина;
		}
	}

	личный статичный цел маскаБукв(Строка буквы) {
		цел маска = 0;
		для (символ сим: буквы.кМассивуСимволов()){
			маска |= 1 << (сим-'а');
		}
		верни маска;
	}

	личный тщетный вывод(Строка строка){
		Система.вывод.append("|");
		Система.вывод.append(ПРОБЕЛЫ, 0, 2*глубина);
		Система.вывод.println(строка);
	}

	личный ТипизированныйЗапрос<MorphemDescr> запрос(Строка искомое, ЧастьРечи частьРечи){
		СборщикКритериев ск = св.дайСборщикКритериев();
		КритериальныйЗапрос<MorphemDescr> кз = ск.createQuery(MorphemDescr.класс);
		Root<MorphemDescr> корень = кз.from(MorphemDescr.класс);

		Predicate predicate = частьРечи == ЧастьРечи.любой ? ск.и() :
			ск.или(
				ск.равны(корень.get(MorphemDescr_.целевойТип), частьРечи),
				ск.равны(корень.get(MorphemDescr_.целевойТип), ЧастьРечи.любой),
				ск.и(
					ск.равны(корень.get(MorphemDescr_.целевойТип), ЧастьРечи.тотже),
					ск.равны(корень.get(MorphemDescr_.исходныйТип), частьРечи)
				)
			);

		predicate = ск.и(
				predicate,
				ск.равны(корень.get(MorphemDescr_.тип), ТипМорфемы.СУФФИКС),
				ск.мен(ск.длина(корень.get(MorphemDescr_.обрат)), искомое.длина()),
				ск.равны(ск.поиск(ск.литерал(переверни(искомое)), корень.get(MorphemDescr_.обрат)), 1)
		);
		кз.where(predicate);

		верни св.создайЗапрос(кз);
	}

	Строка переверни(Строка знач){
		StringBuilder сс = новый StringBuilder(знач.длина());
		символ символы[] = знач.кМассивуСимволов();
		для (цел указ = знач.длина()-1; указ >= 0; указ--){
			сс.append(символы[указ]);
		}
		верни сс.строкой();
	}

	личный статичный итоговый Logger ЖУРНАЛ = Logger.getLogger(Генератор.класс.дайИмя());
}
