/*
 * Авторское право принадлежит Антону Александровичу Астафьеву <anton@astafiev.me> (Anton Astafiev) ѱ.
 * Все права защищены и охраняются законом.
 * Copyright (c) 2016 Антон Александрович Астафьев <anton@astafiev.me> (Anton Astafiev). All rights reserved.
 *
 *  Собственная лицензия Астафьева
 * Данный программный код является собственностью Астафьева Антона Александровича
 * и может быть использован только с его личного разрешения
 */

пакет эллиптика.ява.язык;

внеся java.util.regex.Pattern;
внеся java.util.stream.Collectors;
внеся java.util.Коллекция;
внеся java.util.Массивы;
внеся java.util.МножествоСвёрток;
внеся java.util.ПорядковыйСписок;
внеся java.util.Список;
внеся org.elliptica.ling.Morph;
внеся org.elliptica.ling.syntax.Вариант;
внеся org.elliptica.ling.syntax.Группа;
внеся org.elliptica.ling.syntax.Омоним;
внеся org.elliptica.ling.syntax.Предложение;
внеся org.elliptica.ling.syntax.Синтаксис;
внеся org.elliptica.ling.syntax.СинтаксическоеДерево;
внеся org.elliptica.ling.syntax.Слово;
внеся org.elliptica.ling.Граммема;
внеся org.elliptica.ling.Парадигма;
внеся org.elliptica.ling.ФормаСлова;
внеся org.elliptica.ling.ЧастьРечи;
внеся эллиптика.ява.синтаксис.структ.ГруппаСтруктуры;
внеся эллиптика.ява.синтаксис.структ.ФабрикаСтруктуры;

/**
 *
 * @author Антон Александрович Астафьев {@literal <anton@astafiev.me>} (Anton Astafiev)
 */
класс ДелегатЛингвистикиВопл воплощает ДелегатЛингвистики {

	личный сопряжение ЦелевыеФормы {
		Список<Граммема> дляСлова();
		Список<Граммема> дляФразы(Список<Граммема> граммемы);
	}

	@Подмени
	доступный Строка подбериМножЧислоФразы(символ[] символыФразы) {
		ЦелевыеФормы формы = новый ЦелевыеФормы(){
			@Override
			доступный Список<Граммема> дляСлова() {
				верни Массивы.списком(Граммема.множественное, Граммема.именительный);
			}

			@Override
			доступный Список<Граммема> дляФразы(Список<Граммема> граммемы) {
				граммемы.удали(Граммема.единственное);
				граммемы.добавь(Граммема.множественное);
				верни граммемы;
			}
		};
		верни подбериФормуФразы(символыФразы, формы);
	}

	@Подмени
	доступный Строка подбериЗадануюФормуФразы(символ[] символыФразы, Коллекция<Граммема> целевыеГраммемы) {
		ЦелевыеФормы формы = новый ЦелевыеФормы(){
			@Override
			доступный Список<Граммема> дляСлова() {
				верни новый ПорядковыйСписок<>(целевыеГраммемы);
			}

			@Override
			доступный Список<Граммема> дляФразы(Список<Граммема> граммемы) {
				для (Граммема граммема: целевыеГраммемы){
					для (Граммема г: граммема.тип().значения()){
						если (г == граммема){
							возобнови;
						}
						граммемы.удали(г);
					}
					граммемы.добавь(граммема);
				}
				верни граммемы;
			}
		};
		верни подбериФормуФразы(символыФразы, формы);
	}

	доступный Строка подбериФормуФразы(символ[] символыФразы, ЦелевыеФормы формы) {
		ClassLoader oldCL = Thread.currentThread().getContextClassLoader();
		Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader());

		System.setProperty("jmorph.rml.dir", ПУТЬ_К_СЛОВАРЯМ);

		Строка вход = новый Строка(символыФразы);
		Строка[] слова = ШАБЛОН.split(вход);
		Строка выход;
		
		если (слова.length == 0){
			верни ничто;
		}
		если (слова.length == 1){
			Строка начФорма = "";
			для (Парадигма парадигма: Morph.найдиСлово(слова[0]).дайПарадигмы()){
				начФорма = парадигма.дайБазовуюФорму();
				если (парадигма.дайЧастьРечи() == ЧастьРечи.существительное){
					прерви;
				}
			}
			ФормаСлова фс = Morph.найдиФорму(начФорма, новый МножествоСвёрток<Граммема>( формы.дляСлова() ));
			выход = фс.дайСлово().вНижнемРегистре();
			если ( Character.isUpperCase(вход.символВ(0)) ){
				выход = Character.toUpperCase( выход.символВ(0) ) + выход.подстрока(1) ;
			}
			верни выход;
		}

		Строка фраза = "Проверяется";
		для (Строка слово : слова) {
			фраза += " " + слово.вНижнемРегистре();
		}
		
		СинтаксическоеДерево результат = дайСинтаксис().разборТекста(фраза);

		Предложение предложение = результат.getПредложения().дай(0);
		Слово слово = предложение.дайСписокСлов().дай(1);
		Омоним омоним = слово.дайОмонимы().дай(0);
		Вариант вариант = омоним.дайЮнит().родитель();
		Список<Группа> группы = вариант.дайГруппы();

		Integer[] основа = новый Integer[2];
		группы.поток().filter(группа -> группа.дайТип() == Группа.Тип.ОСНОВА).findAny().ifPresent(
			группа -> {
				основа[0] = группа.дайНачало();
				основа[1] = группа.дайКонец();
			}
		);
		
		если (основа[0] == ничто || основа[1] == ничто) {
			верни вход;
		}

		Список<Группа> итоговыеГруппы = группы.поток()
				.filter(гр -> гр.дайНачало() != основа[1] && гр.дайКонец() != основа[1] )
				.collect(Collectors.toList());
		Список<Омоним> омонимы = вариант.дайЮниты().поток()
				.map(юнит -> юнит.дайОмоним())
				.collect(Collectors.toList());

		ГруппаСтруктуры группаСтруктуры = ФабрикаСтруктуры.создайСтруктуру(итоговыеГруппы, омонимы);
		
		если (группаСтруктуры == ничто){
			верни вход;
		}

		Список<Граммема> граммемы = формы.дляФразы( группаСтруктуры.дайГраммемы() );
		группаСтруктуры.смениФорму(граммемы);

		выход = группаСтруктуры.дайФразу();
		если ( Character.isUpperCase(вход.символВ(0)) ){
			выход = " " + выход;
		}
		символ[] символы = выход.кМассивуСимволов();
		цел й = 0;
		для (цел и = 0; и < символы.length; и++, й++) {
			если (символы[и] == ' '){
				если (и + 1 < символы.length){
					и++;
					символы[й] = Character.toUpperCase(символы[и]);
				}
			} иначе {
					символы[й] = символы[и];
			}
		}

		Thread.currentThread().setContextClassLoader(oldCL);

		верни новый Строка(символы, 0, й);
	}

	личный статичный Синтаксис дайСинтаксис(){
		если (ничто == синтаксис)  {
			синтаксис = новый Синтаксис(ПУТЬ_К_СЛОВАРЯМ);
		}
		верни синтаксис;
	}

	личный статичный итоговый Строка РАЗДЕЛИТЕЛЬ = "(?=[А-ЯЁ][а-яё]*($|[А-ЯЁ]))";
	личный статичный итоговый Pattern ШАБЛОН = Pattern.compile(РАЗДЕЛИТЕЛЬ);

	личный статичный итоговый Строка ПУТЬ_К_СЛОВАРЯМ = "/mnt/f16/mahairod/Develop/cpp/linguistan/";
	личный статичный Синтаксис синтаксис;


}
